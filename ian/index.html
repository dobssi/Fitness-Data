<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ian Lilley Fitness Dashboard</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üèÉ</text></svg>">
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3"></script>
    <style>
        :root {
            --bg: #0f1117;
            --surface: #1a1d27;
            --surface2: #232733;
            --border: #2e3340;
            --text: #e4e7ef;
            --text-dim: #8b90a0;
            --text-muted: #565b6b;
            --accent: #818cf8;
            --z1: #3b82f6;
            --z2: #22c55e;
            --z3: #eab308;
            --z4: #f97316;
            --z5: #ef4444;
            --grid: rgba(255,255,255,0.04);
        }
        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'DM Sans', -apple-system, BlinkMacSystemFont, sans-serif;
            padding: 14px;
            background: var(--bg);
            color: var(--text);
            font-size: 14px;
        }
        
        h1 {
            font-size: 1.4rem;
            font-weight: 700;
            letter-spacing: -0.02em;
            margin: 0 0 4px 0;
            text-align: center;
        }
        .dash-sub {
            text-align: center;
            color: var(--text-dim);
            font-size: 0.82rem;
            margin-bottom: 14px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-bottom: 10px;
        }
        
        .stat-card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 10px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 1.45em;
            font-weight: 700;
            color: var(--accent);
            font-family: 'JetBrains Mono', monospace;
        }
        
        .stat-label {
            font-size: 0.78em;
            color: var(--text-dim);
            margin-top: 2px;
            font-weight: 500;
        }
        
        .stat-sub {
            font-size: 0.7em;
            color: var(--text-muted);
        }
        
        .card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 14px;
            margin-bottom: 12px;
        }
        
        .card h2 {
            font-size: 0.9rem;
            font-weight: 600;
            margin: 0 0 10px 0;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .card-header {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: center;
            gap: 6px;
            margin-bottom: 8px;
        }
        
        .card-description {
            font-size: 0.75em;
            color: var(--text-dim);
            margin-bottom: 10px;
            line-height: 1.3;
        }
        
        .badge {
            font-size: 0.68rem;
            font-weight: 500;
            background: var(--surface2);
            border: 1px solid var(--border);
            padding: 2px 8px;
            border-radius: 4px;
            color: var(--text-dim);
        }

        .chart-wrapper {
            position: relative;
            height: 220px;
            width: 100%;
        }
        
        /* Zone tables */
        .zt {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.8rem;
            min-width: 0;
            table-layout: auto;
        }
        .zt th {
            text-align: left;
            padding: 5px 6px;
            color: var(--text-dim);
            font-weight: 500;
            border-bottom: 1px solid var(--border);
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .zt td {
            padding: 5px 6px;
            border-bottom: 1px solid var(--border);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.78rem;
        }
        .zt tr:last-child td { border-bottom: none; }
        .zd {
            width: 7px; height: 7px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 4px;
            vertical-align: middle;
        }
        
        /* Weekly zone bars */
        .wr { display: flex; align-items: center; gap: 6px; margin-bottom: 4px; }
        .wl { font-size: 0.72rem; font-family: 'JetBrains Mono'; color: var(--text-dim); width: 52px; flex-shrink: 0; }
        .wb { flex: 1; height: 20px; display: flex; border-radius: 3px; overflow: visible; background: rgba(255,255,255,0.02); }
        .ws { height: 100%; transition: width 0.3s; position: relative; cursor: pointer; }
        .ws:first-child { border-radius: 3px 0 0 3px; }
        .ws:last-child { border-radius: 0 3px 3px 0; }
        .ws:only-child { border-radius: 3px; }
        .ws:hover { filter: brightness(1.15); }
        .ws .tip { display: none; position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%); background: var(--surface2); border: 1px solid var(--border); padding: 3px 7px; border-radius: 4px; font-size: 0.68rem; white-space: nowrap; z-index: 10; color: var(--text); pointer-events: none; margin-bottom: 4px; }
        .ws:hover .tip { display: block; }
        .wt { font-size: 0.72rem; font-family: 'JetBrains Mono'; color: var(--text-dim); width: 48px; text-align: right; flex-shrink: 0; }
        
        /* Race readiness cards */
        .rc { background: var(--surface2); border-radius: 8px; padding: 12px; margin-bottom: 8px; }
        .rc:last-child { margin-bottom: 0; }
        .rh { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .rn { font-weight: 600; font-size: 0.88rem; }
        .rd { font-size: 0.72rem; color: var(--text-dim); font-family: 'JetBrains Mono'; }
        .rs { display: grid; grid-template-columns: repeat(4, 1fr); gap: 6px; }
        .rv { font-size: 1.1rem; font-weight: 700; font-family: 'JetBrains Mono'; text-align: center; }
        .rl { font-size: 0.68rem; color: var(--text-dim); text-align: center; margin-top: 1px; }
        .rx { font-size: 0.64rem; color: var(--text-muted); text-align: center; }
        
        /* Legend */
        .legend { display: flex; gap: 10px; margin-top: 8px; flex-wrap: wrap; }
        .lg { display: flex; align-items: center; gap: 4px; font-size: 0.7rem; color: var(--text-dim); }
        .lsw { width: 9px; height: 9px; border-radius: 2px; flex-shrink: 0; }
        
        .note {
            font-size: 0.72rem;
            color: var(--text-muted);
            margin-top: 10px;
            padding: 8px 10px;
            background: var(--surface2);
            border-radius: 6px;
            border-left: 3px solid var(--accent);
        }
        
        .table-wrapper {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            margin: 0 -14px;
            padding: 0 14px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.78em;
            table-layout: fixed;
            min-width: 500px;
        }
        
        th, td {
            padding: 5px 3px;
            text-align: left;
            border-bottom: 1px solid var(--border);
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        td:nth-child(2), td:nth-child(3) {
            white-space: normal;
            word-wrap: break-word;
            line-height: 1.2;
        }
        
        th {
            font-weight: 500;
            color: var(--text-dim);
            font-size: 0.7em;
            text-transform: uppercase;
            white-space: nowrap;
            letter-spacing: 0.03em;
        }
        
        .race-badge {
            background: #fbbf24;
            color: #000;
            padding: 1px 4px;
            border-radius: 3px;
            font-size: 0.65em;
            font-weight: bold;
        }
        
        .footer {
            text-align: center;
            font-size: 0.72em;
            color: var(--text-muted);
            margin-top: 16px;
            padding-top: 12px;
            border-top: 1px solid var(--border);
        }
        
        @media (min-width: 600px) {
            body {
                max-width: 900px;
                margin: 0 auto;
                padding: 20px;
            }
            .stats-grid {
                grid-template-columns: repeat(4, 1fr);
            }
            .chart-wrapper {
                height: 280px;
            }
            .zgrid {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 12px;
            }
        }
        @media (max-width: 599px) {
            .rs { grid-template-columns: repeat(2, 1fr); }
        }
        
        /* Legacy chart classes ‚Äî dark theme */
        .chart-container {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 14px;
            margin-bottom: 12px;
        }
        .chart-header {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-bottom: 10px;
        }
        .chart-title {
            font-size: 0.9rem;
            font-weight: 600;
            font-family: 'DM Sans', -apple-system, sans-serif;
            margin-bottom: 2px;
        }
        .chart-title-row {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-bottom: 8px;
        }
        .chart-title-row .chart-title {
            margin-bottom: 0;
        }
        .chart-toggle {
            display: inline-flex;
            gap: 2px;
            background: var(--surface2);
            border-radius: 6px;
            padding: 2px;
            align-self: flex-start;
        }
        .chart-toggle button {
            font-family: 'DM Sans', sans-serif;
            font-size: 0.72rem;
            padding: 4px 10px;
            border-radius: 5px;
            border: none;
            background: transparent;
            color: var(--text-dim);
            cursor: pointer;
            transition: all 0.15s;
        }
        .chart-toggle button:hover {
            color: var(--text);
        }
        .chart-toggle button.active {
            background: var(--accent);
            color: #fff;
        }
        .chart-desc {
            font-size: 0.75em;
            color: var(--text-dim);
            margin-bottom: 12px;
            line-height: 1.4;
        }
        
        /* Zone tables: single-card layout */
        .zone-combined {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 24px;
        }
        @media (max-width: 599px) {
            .zone-combined { grid-template-columns: 1fr; gap: 16px; }
            .zt { font-size: 0.72rem; }
            .zt th, .zt td { padding: 4px 4px; }
            .zt .pct-col { display: none; }
            .race-card { grid-template-columns: 1fr 1fr !important; }
        }
    </style>
</head>
<body class="gap-mode">
<script>try{Chart.defaults.color="#8b90a0";Chart.defaults.borderColor="rgba(255,255,255,0.04)";Chart.defaults.font.family="'DM Sans',sans-serif";Chart.defaults.plugins.legend.labels.padding=10;
const _today = new Date(); _today.setHours(0,0,0,0);
const _14dFromNow = new Date(_today.getTime() + 14*86400000);
// Format ISO date "2026-02-21" to match chart label formats
function _isoToShort(iso) {
    // -> "21 Feb" (matches RFL 14-day chart '%d %b')
    const d = new Date(iso + 'T00:00:00');
    const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
    return String(d.getDate()).padStart(2,'0') + ' ' + months[d.getMonth()];
}
function _isoToMedium(iso) {
    // -> "21 Feb 26" (matches CTL chart '%d %b %y')
    const d = new Date(iso + 'T00:00:00');
    const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
    return String(d.getDate()).padStart(2,'0') + ' ' + months[d.getMonth()] + ' ' + String(d.getFullYear()).slice(2);
}
function raceAnnotations(dates) {
    const pColors = {'A': '#f87171', 'B': '#fbbf24', 'C': '#6b7280'};
    const pDash = {'A': [], 'B': [6,3], 'C': [3,3]};
    const annots = {};
    if (!dates || dates.length === 0) return annots;
    // Find only the NEXT upcoming race
    const upcoming = PLANNED_RACES.filter(r => {
        const rd = new Date(r.date + 'T00:00:00');
        return rd >= _today;
    }).sort((a,b) => a.date.localeCompare(b.date));
    if (upcoming.length === 0) return annots;
    const r = upcoming[0];
    const rd = new Date(r.date + 'T00:00:00');
    if (rd > _14dFromNow) return annots;
    const short = _isoToShort(r.date);
    const medium = _isoToMedium(r.date);
    let matchLabel = null;
    if (dates.includes(short)) matchLabel = short;
    else if (dates.includes(medium)) matchLabel = medium;
    if (matchLabel) {
        annots['race_next'] = {
            type: 'line', xMin: matchLabel, xMax: matchLabel,
            borderColor: pColors[r.priority] || '#fbbf24',
            borderWidth: r.priority === 'A' ? 2 : 1.5,
            borderDash: pDash[r.priority] || [6,3],
            label: { display: true, content: r.name, position: 'start',
                backgroundColor: 'rgba(15,17,23,0.85)',
                color: pColors[r.priority] || '#fbbf24',
                font: { size: 10, family: "'DM Sans'" },
                padding: {x:4,y:2}, borderRadius: 3
            }
        };
    }
    return annots;
}


}catch(e){console.warn('Chart.js not loaded:',e);}
</script>
    <h1>üèÉ Ian Lilley</h1>
    <div class="dash-sub">Friday 20 February 2026, 07:39</div>
    
    <!-- Phase 2: Mode Toggle -->
    <div class="mode-toggle" style="display:flex;gap:6px;margin:10px 0 8px;align-items:center;display:none;">
        <span style="font-size:0.72rem;color:var(--text-dim);margin-right:4px;">Model:</span>
        <button class="mode-btn" onclick="setMode('stryd')" id="mode-stryd">‚ö° Stryd</button>
        <button class="mode-btn active" onclick="setMode('gap')" id="mode-gap">üèÉ GAP</button>
        <button class="mode-btn" onclick="setMode('sim')" id="mode-sim">üî¨ Sim</button>
    </div>
    <style>
        .mode-btn { font-family:'DM Sans',sans-serif; font-size:0.75rem; padding:5px 12px; border-radius:16px;
            border:1px solid var(--border); background:var(--surface); color:var(--text-dim); cursor:pointer; transition:all 0.15s; }
        .mode-btn:hover { border-color:var(--accent); color:var(--text); }
        .mode-btn.active { background:var(--accent); color:#fff; border-color:var(--accent); }
        body.gap-mode .power-only { display:none !important; }
        body.sim-mode .stryd-only { display:none !important; }
        body.gap-mode .stryd-only { display:none !important; }
        body.gap-mode .pace-target { display:block !important; }
        .gap-only { display:none !important; }
        body.gap-mode .gap-only { display:inline-block !important; }
    </style>
    
    <!-- v51: Health Check Banner -->
    <div id="alert-banner"></div>
    <script>
    const _alertData = {"stryd": [], "gap": [], "sim": []};
    function renderAlertBanner(mode) {
        const el = document.getElementById('alert-banner');
        const alerts = _alertData[mode] || [];
        const ms = (typeof modeStats !== 'undefined') ? modeStats[mode] : null;
        const cpVal = ms ? ms.cp : 300;
        const cpHtml = (mode !== 'gap' && cpVal > 0) ? '<span class="power-only" style="font-size:0.82em;color:#8b90a0;">‚ö° CP ' + cpVal + 'W</span>' : '';
        if (alerts.length === 0) {
            el.innerHTML = '<div style="background:rgba(34,197,94,0.08);border:1px solid rgba(34,197,94,0.3);border-radius:10px;padding:10px 16px;margin-bottom:14px;display:flex;justify-content:center;align-items:center;gap:8px;"><span style="font-size:1.1em;">üü¢</span> <strong style="color:#4ade80;">All clear</strong> <span style="color:#8b90a0;">‚Äî no alerts</span>' + cpHtml + '</div>';
            return;
        }
        const hasConcern = alerts.some(a => a.level === 'concern');
        const bg = hasConcern ? 'rgba(239,68,68,0.08)' : 'rgba(234,179,8,0.08)';
        const brd = hasConcern ? 'rgba(239,68,68,0.3)' : 'rgba(234,179,8,0.3)';
        const icon = hasConcern ? 'üî¥' : 'üü°';
        const lc = hasConcern ? '#f87171' : '#fbbf24';
        const n = alerts.length;
        const s = n > 1 ? 's' : '';
        const items = alerts.map(a => '<div style="margin:4px 0;font-size:0.85em;color:#e4e7ef;">' + a.icon + ' <strong>' + a.name + '</strong><span style="color:#8b90a0"> ' + a.detail + '</span></div>').join('');
        el.innerHTML = '<div style="background:'+bg+';border:1px solid '+brd+';border-radius:10px;padding:10px 16px;margin-bottom:14px;"><div style="text-align:center;margin-bottom:4px;"><span style="font-size:1.1em;">'+icon+'</span> <strong style="color:'+lc+';">'+n+' alert'+s+' active</strong>' + cpHtml + '</div>'+items+'</div>';
    }
    renderAlertBanner(typeof currentMode !== 'undefined' ? currentMode : 'stryd');
    </script>
    
    <!-- Stats Cards -->
    <div class="stats-grid">
        <div class="stat-card">
            <div class="stat-value" id="ctl-value">1.8</div>
            <div class="stat-label">CTL</div>
            <div class="stat-sub">fitness</div>
        </div>
        <div class="stat-card">
            <div class="stat-value" id="atl-value">10.8</div>
            <div class="stat-label">ATL</div>
            <div class="stat-sub">fatigue</div>
        </div>
        <div class="stat-card">
            <div class="stat-value" id="tsb-value">-9</div>
            <div class="stat-label">TSB</div>
            <div class="stat-sub">form</div>
        </div>
        <div class="stat-card">
            <div class="stat-value">-</div>
            <div class="stat-label">Weight</div>
            <div class="stat-sub">7d average</div>
        </div>
    </div>
    
    <div class="stats-grid">
        <div class="stat-card">
            <div class="stat-value" id="rfl-value">100%</div>
            <div class="stat-label" id="rfl-label">RFL (GAP)</div>
            <div class="stat-sub">vs peak</div>
        </div>
        <div class="stat-card">
            <div class="stat-value" id="rfl-delta">-</div>
            <div class="stat-label">RFL 14d</div>
            <div class="stat-sub">change</div>
        </div>
        <div class="stat-card">
            <div class="stat-value" id="easy-rf-gap-value"
                 data-stryd="0%"
                 data-gap="0%"
                 data-sim="0%"
            >0%</div>
            <div class="stat-label">Easy RF Gap</div>
            <div class="stat-sub">vs trend</div>
        </div>
        <div class="stat-card">
            <div class="stat-value" id="ag-value">81.6%</div>
            <div class="stat-label">Age Grade</div>
            <div class="stat-sub">5k estimate</div>
        </div>
    </div>
    
    <div class="stats-grid">
        <div class="stat-card">
            <div class="stat-value" id="pred-5k">18:29</div>
            <div class="stat-label">5k</div>
            <div class="stat-sub">predicted</div>
        </div>
        <div class="stat-card">
            <div class="stat-value" id="pred-10k">38:48</div>
            <div class="stat-label">10k</div>
            <div class="stat-sub">predicted</div>
        </div>
        <div class="stat-card">
            <div class="stat-value" id="pred-hm">1:26:11</div>
            <div class="stat-label">Half</div>
            <div class="stat-sub">predicted</div>
        </div>
        <div class="stat-card">
            <div class="stat-value" id="pred-mara">3:03:59</div>
            <div class="stat-label">Marathon</div>
            <div class="stat-sub">predicted</div>
        </div>
    </div>
    
    <div class="stats-grid">
        <div class="stat-card">
            <div class="stat-value">11.9</div>
            <div class="stat-label">Last 7 Days</div>
            <div class="stat-sub">km</div>
        </div>
        <div class="stat-card">
            <div class="stat-value">11.9</div>
            <div class="stat-label">Last 30 Days</div>
            <div class="stat-sub">km</div>
        </div>
        <div class="stat-card">
            <div class="stat-value">12</div>
            <div class="stat-label">Last 12 Months</div>
            <div class="stat-sub">km</div>
        </div>
        <div class="stat-card">
            <div class="stat-value">1</div>
            <div class="stat-label">Total Runs</div>
            <div class="stat-sub">since 2026</div>
        </div>
    </div>
    
    <!-- RF Trend Chart -->
    
    <!-- Training Zones Section -->
    
    <div class="card" id="zone-table-card">
        <h2>Training Zones <span class="badge" id="zone-badge">CP 300W ¬∑ LTHR 157 ¬∑ Max ~175</span></h2>
        <table class="zt"><thead><tr><th>Zone</th><th></th><th>HR</th><th class="power-only">Power</th><th class="power-only pct-col">%CP</th></tr></thead><tbody><tr><td><span class="zd" style="background:#3b82f6"></span><strong>Z1</strong></td><td style="color:var(--text-dim);font-family:DM Sans">Easy</td><td><127</td><td class="power-only"><243W</td><td class="power-only pct-col" style="color:var(--text-dim)"><81%</td></tr><tr><td><span class="zd" style="background:#22c55e"></span><strong>Z2</strong></td><td style="color:var(--text-dim);font-family:DM Sans">Aerobic</td><td>127‚Äì141</td><td class="power-only">243‚Äì269W</td><td class="power-only pct-col" style="color:var(--text-dim)">81‚Äì90%</td></tr><tr><td><span class="zd" style="background:#eab308"></span><strong>Z3</strong></td><td style="color:var(--text-dim);font-family:DM Sans">Tempo</td><td>141‚Äì150</td><td class="power-only">269‚Äì287W</td><td class="power-only pct-col" style="color:var(--text-dim)">90‚Äì96%</td></tr><tr><td><span class="zd" style="background:#f97316"></span><strong>Z4</strong></td><td style="color:var(--text-dim);font-family:DM Sans">Threshold</td><td>150‚Äì157</td><td class="power-only">287‚Äì300W</td><td class="power-only pct-col" style="color:var(--text-dim)">96‚Äì100%</td></tr><tr><td><span class="zd" style="background:#ef4444"></span><strong>Z5</strong></td><td style="color:var(--text-dim);font-family:DM Sans">Max</td><td>>157</td><td class="power-only">>300W</td><td class="power-only pct-col" style="color:var(--text-dim)">>100%</td></tr></tbody></table>
    </div>

    <div class="card" id="race-readiness-card">
        <h2>üéØ Race Readiness <span class="badge">¬±3% of target</span></h2>
        <div class="rc">
            <div class="rh">
                <span class="rn">Burgess Parkrun <span style="font-size:0.65rem;padding:2px 6px;border-radius:4px;background:#8b90a022;color:#8b90a0;font-weight:600;margin-left:6px;vertical-align:middle">C RACE</span></span>
                <span class="rd">2026-02-28 ¬∑ 8d</span>
            </div>
            <div class="rs">
                <div class="power-only"><div class="rv" style="color:var(--accent)" id="race-pw-0">315W</div><div class="rl">Target</div><div class="rx">¬±9W</div></div>
                <div class="pace-target" style="display:none"><div class="rv" style="color:#4ade80" id="race-pace-0">3:41/km</div><div class="rl">Target pace</div></div>
                <div><div class="rv" id="race-pred-0">18:29</div><div class="rl">Predicted</div><div class="rx power-only">3:41/km</div></div>
                <div><div class="rv" id="spec14_0">0<span style="font-size:0.75rem;color:var(--text-dim)">min</span></div><div class="rl">14d at effort</div></div>
                <div><div class="rv" id="spec28_0">0<span style="font-size:0.75rem;color:var(--text-dim)">min</span></div><div class="rl">28d at effort</div></div>
            </div>
            <div style="margin-top:6px"></div>
        </div><div class="rc">
            <div class="rh">
                <span class="rn">Paddock Wood Half <span style="font-size:0.65rem;padding:2px 6px;border-radius:4px;background:#f8717122;color:#f87171;font-weight:600;margin-left:6px;vertical-align:middle">A RACE</span></span>
                <span class="rd">2026-03-08 ¬∑ 16d</span>
            </div>
            <div class="rs">
                <div class="power-only"><div class="rv" style="color:var(--accent)" id="race-pw-1">285W</div><div class="rl">Target</div><div class="rx">¬±9W</div></div>
                <div class="pace-target" style="display:none"><div class="rv" style="color:#4ade80" id="race-pace-1">4:05/km</div><div class="rl">Target pace</div></div>
                <div><div class="rv" id="race-pred-1">1:26:11</div><div class="rl">Predicted</div><div class="rx power-only">4:05/km</div></div>
                <div><div class="rv" id="spec14_1">0<span style="font-size:0.75rem;color:var(--text-dim)">min</span></div><div class="rl">14d at effort</div></div>
                <div><div class="rv" id="spec28_1">0<span style="font-size:0.75rem;color:var(--text-dim)">min</span></div><div class="rl">28d at effort</div></div>
            </div>
            <div style="margin-top:6px"><span style="color:#fbbf24;font-size:0.72rem">‚è≥ Taper starts in 2d</span></div>
        </div>
    </div>

    <div class="card">
        <h2>üìä Weekly Zone Volume</h2>
        <div style="display:flex;gap:6px;flex-wrap:wrap;margin-bottom:10px">
            <div class="chart-toggle" id="wk-mode">
                <button class="active" onclick="setWM('hr',this)">HR Zone</button>
                <button class="power-only" onclick="setWM('power',this)">Power Zone</button>
                <button class="power-only" onclick="setWM('race',this)">Race (W)</button>
                <button class="gap-only" onclick="setWM('race',this)">Race (Pace)</button>
                <button onclick="setWM('racehr',this)">Race (HR)</button>
            </div>
            <div class="chart-toggle" id="wk-period">
                <button class="active" onclick="setWP(8,this)">8w</button>
                <button onclick="setWP(12,this)">12w</button>
                <button onclick="setWP(16,this)">16w</button>
            </div>
        </div>
        <div id="wk-bars"><div class="wr"><div class="wl">W08/26</div><div class="wb"><div class="ws" style="width:100.0%;background:#22c55e"><div class="tip">Aerobic: 62 min</div></div></div><div class="wt">62 min</div></div></div>
        <div id="wk-leg" class="legend"><div class="lg"><div class="lsw" style="background:#3b82f6"></div>Easy</div><div class="lg"><div class="lsw" style="background:#22c55e"></div>Aerobic</div><div class="lg"><div class="lsw" style="background:#eab308"></div>Tempo</div><div class="lg"><div class="lsw" style="background:#f97316"></div>Threshold</div><div class="lg"><div class="lsw" style="background:#ef4444"></div>Max</div></div>
    </div>

    <div class="card">
        <h2>üìä Per-Run Distribution <span class="badge">last 30</span></h2>
        <div style="margin-bottom:10px">
            <div class="chart-toggle" id="pr-mode">
                <button class="active" onclick="setPR('hr',this)">HR Zone</button>
                <button class="power-only" onclick="setPR('power',this)">Power Zone</button>
                <button class="power-only" onclick="setPR('race',this)">Race (W)</button>
                <button class="gap-only" onclick="setPR('race',this)">Race (Pace)</button>
                <button onclick="setPR('racehr',this)">Race (HR)</button>
            </div>
        </div>
        <div id="pr-static"><div class="wr"><div class="wl">19/2</div><div class="wb"><div class="ws" style="width:100.0%;background:#22c55e"><div class="tip">Afternoon run: 62 min Aerobic</div></div></div><div class="wt">62 min</div></div></div>
        <div class="chart-wrapper" id="pr-canvas-wrap" style="display:none"><canvas id="prChart"></canvas></div>
        <div id="pr-leg" class="legend"></div>
        <div class="note">Zone split from 30s rolling average of per-second power/HR data where available.</div>
    </div>

    <script>
    const ZONE_RUNS=[{"date": "2026-02-19", "name": "Afternoon run", "avg_hr": 136.2, "npower": 22106, "duration_min": 62.5, "distance_km": 11.9, "avg_pace_skm": 314, "race": false, "hz": {"Z1": 19.2, "Z2": 18.2, "Z3": 6.8, "Z4": 12.8, "Z5": 4.3}, "pz": {"Z1": 9.6, "Z2": 1.2, "Z3": 0.8, "Z4": 0.8, "Z5": 49.0}, "rpz": {"Other": 10.0, "Mara": 1.2, "HM": 0.7, "10K": 0.8, "5K": 1.4, "Sub-5K": 47.2}, "rhz": {"Other": 39.6, "Mara": 5.5, "HM": 11.8, "10K": 4.3, "5K": 0.0, "Sub-5K": 0.0}, "rpz_gap": {"Sub-5K": 2.4, "5K": 3.5, "10K": 11.4, "HM": 2.6, "Mara": 1.8, "Other": 39.6}}];
    const PLANNED_RACES=[{"name": "Burgess Parkrun", "date": "2026-02-28", "priority": "C", "distance_key": "5K", "distance_km": 5.0, "surface": "road"}, {"name": "Paddock Wood Half", "date": "2026-03-08", "priority": "A", "distance_key": "HM", "distance_km": 21.097, "surface": "road"}];
    const ZONE_CP=300;const ZONE_PEAK_CP=300;const ZONE_MASS=87.0;const ZONE_RE=0.097;const ZONE_LTHR=157;const ZONE_MAXHR=175;
    const HR_Z=[
      {id:'Z1',name:'Easy',lo:0,hi:127,c:'#3b82f6'},
      {id:'Z2',name:'Aerobic',lo:127,hi:141,c:'#22c55e'},
      {id:'Z3',name:'Tempo',lo:141,hi:150,c:'#eab308'},
      {id:'Z4',name:'Threshold',lo:150,hi:157,c:'#f97316'},
      {id:'Z5',name:'Max',lo:157,hi:9999,c:'#ef4444'}
    ];
    const RF_THR=ZONE_CP/ZONE_LTHR;
    const PW_Z12=Math.round(RF_THR*127);
    const PW_Z23=Math.round(RF_THR*141);
    const PW_Z34=Math.round(RF_THR*150);
    const PW_Z45=ZONE_CP;
    const PW_Z=[
      {id:'Z1',name:'Easy',lo:0,hi:PW_Z12,c:'#3b82f6'},
      {id:'Z2',name:'Aerobic',lo:PW_Z12,hi:PW_Z23,c:'#22c55e'},
      {id:'Z3',name:'Tempo',lo:PW_Z23,hi:PW_Z34,c:'#eab308'},
      {id:'Z4',name:'Threshold',lo:PW_Z34,hi:PW_Z45,c:'#f97316'},
      {id:'Z5',name:'Max',lo:PW_Z45,hi:9999,c:'#ef4444'}
    ];
    const RACE_CFG={};
    ['Sub-5K','5K','10K','HM','Mara'].forEach(k=>{
      const f={'Sub-5K':1.07,'5K':1.05,'10K':1.00,'HM':0.95,'Mara':0.90}[k],pw=Math.round(ZONE_CP*f);
      const dists={'Sub-5K':3,'5K':5,'10K':10,'HM':21.097,'Mara':42.195};
      const cols={'Sub-5K':'#4ade80','5K':'#f472b6','10K':'#fb923c','HM':'#a78bfa','Mara':'#38bdf8'};
      RACE_CFG[k]={pw,dist:dists[k],color:cols[k]};
    });
    function makeRacePwZones(){const pw=RACE_CFG,m=pw['Mara'].pw,h=pw['HM'].pw,t=pw['10K'].pw,f=pw['5K'].pw;const mh=Math.round((m+h)/2),ht=Math.round((h+t)/2),tf=Math.round((t+f)/2),above=Math.round(f*1.05);return[{id:'Sub-5K',name:'Sub-5K',lo:above,hi:9999,c:'#4ade80'},{id:'5K',name:'5K',lo:tf,hi:above,c:'#f472b6'},{id:'10K',name:'10K',lo:ht,hi:tf,c:'#fb923c'},{id:'HM',name:'HM',lo:mh,hi:ht,c:'#a78bfa'},{id:'Mara',name:'Mara',lo:Math.round(m*0.93),hi:mh,c:'#38bdf8'},{id:'Other',name:'Other',lo:0,hi:Math.round(m*0.93),c:'#4b5563'}];}
    function makeRaceHrZones(){return[{id:'Sub-5K',name:'Sub-5K',lo:170,hi:9999,c:'#4ade80'},{id:'5K',name:'5K',lo:163,hi:170,c:'#f472b6'},{id:'10K',name:'10K',lo:157,hi:163,c:'#fb923c'},{id:'HM',name:'HM',lo:151,hi:157,c:'#a78bfa'},{id:'Mara',name:'Mara',lo:144,hi:151,c:'#38bdf8'},{id:'Other',name:'Other',lo:0,hi:144,c:'#4b5563'}];}
    function makeRacePaceZones(){const p5=222,p10=233,ph=245,pm=262;const s5=Math.round(p5*0.97),m5=Math.round((p5+p10)/2),mt=Math.round((p10+ph)/2),mh=Math.round((ph+pm)/2),slow=Math.round(pm*1.07);return[{id:'Sub-5K',name:'Sub-5K',lo:0,hi:s5,c:'#4ade80'},{id:'5K',name:'5K',lo:s5,hi:m5,c:'#f472b6'},{id:'10K',name:'10K',lo:m5,hi:mt,c:'#fb923c'},{id:'HM',name:'HM',lo:mt,hi:mh,c:'#a78bfa'},{id:'Mara',name:'Mara',lo:mh,hi:slow,c:'#38bdf8'},{id:'Other',name:'Other',lo:slow,hi:9999,c:'#4b5563'}];}
    const RACE_PW_Z=makeRacePwZones(),RACE_HR_Z=makeRaceHrZones(),RACE_PACE_Z=makeRacePaceZones();
    function zonesFor(m){if(m==='hr')return HR_Z;if(m==='power')return PW_Z;if(m==='race'){if(typeof currentMode!=='undefined'&&currentMode==='gap')return RACE_PACE_Z;return RACE_PW_Z;}if(m==='racehr')return RACE_HR_Z;return HR_Z;}
    function valFor(r,m){if(m==='hr'||m==='racehr')return r.avg_hr;if(m==='race'&&typeof currentMode!=='undefined'&&currentMode==='gap')return r.avg_pace_skm;return r.npower;}
    function isRaceMode(m){return m==='race'||m==='racehr';}
    function assignZ(val,zones,rm){if(!val||val<=0)return zones[zones.length-1].id;if(rm){for(const z of zones){if(z.id==='Other')continue;if(val>=z.lo&&val<=z.hi)return z.id;}return'Other';}for(const z of zones){if(val<z.hi)return z.id;}return zones[zones.length-1].id;}
    function assignToZone(val,zones,result,mins){for(const z of zones){if(z.id==='Other')continue;if(val>=z.lo){result[z.id]+=mins;return;}}result['Other']+=mins;}
    function assignToZonePace(val,zones,result,mins){for(const z of zones){if(z.id==='Other')continue;if(val>=z.lo&&val<z.hi){result[z.id]+=mins;return;}}result['Other']+=mins;}
    function estimateRaceEffortMins(r,zones){const result={};zones.forEach(z=>result[z.id]=0);const mins=r.duration_min||0,pw=r.npower||0;if(!pw||!mins){result['Other']=mins;return result;}assignToZone(pw*1.10,zones,result,mins*0.15);assignToZone(pw,zones,result,mins*0.60);assignToZone(pw*0.88,zones,result,mins*0.25);return result;}
    function estimateRaceEffortMinsPace(r,zones){const result={};zones.forEach(z=>result[z.id]=0);const mins=r.duration_min||0,p=r.avg_pace_skm||0;if(!p||!mins){result['Other']=mins;return result;}assignToZonePace(Math.round(p*0.92),zones,result,mins*0.15);assignToZonePace(p,zones,result,mins*0.60);assignToZonePace(Math.round(p*1.10),zones,result,mins*0.25);return result;}
    function estimateRaceEffortMinsHR(r,zones){const result={};zones.forEach(z=>result[z.id]=0);const mins=r.duration_min||0,hr=r.avg_hr||0;if(!hr||!mins){result['Other']=mins;return result;}assignToZone(hr*1.06,zones,result,mins*0.15);assignToZone(hr,zones,result,mins*0.60);assignToZone(hr*0.92,zones,result,mins*0.25);return result;}
    function getZoneMins(r,mode,zones){
      // Use pre-computed NPZ zone data if available
      const isGapMode=(typeof currentMode!=='undefined'&&currentMode==='gap');
      // In GAP mode for race zones, prefer rpz_gap (per-second GAP pace data)
      if(isGapMode&&mode==='race'&&r.rpz_gap){const result={};zones.forEach(z=>result[z.id]=0);Object.keys(r.rpz_gap).forEach(k=>{if(result[k]!==undefined)result[k]=r.rpz_gap[k];});return result;}
      // Skip power-based race/power zones in GAP mode
      const key={hr:'hz',power:'pz',race:'rpz',racehr:'rhz'}[mode];
      if(r[key]&&!(isGapMode&&(key==='rpz'||key==='pz'))){const result={};zones.forEach(z=>result[z.id]=0);Object.keys(r[key]).forEach(k=>{if(result[k]!==undefined)result[k]=r[key][k];});return result;}
      // Fallback to heuristic
      if(mode==='race'){if(isGapMode)return estimateRaceEffortMinsPace(r,zones);return estimateRaceEffortMins(r,zones);}
      if(mode==='racehr')return estimateRaceEffortMinsHR(r,zones);
      // HR/Power zone fallback: assign all time to primary zone
      const result={};zones.forEach(z=>result[z.id]=0);const mins=r.duration_min||0,v=valFor(r,mode),zid=assignZ(v,zones,false);if(result[zid]!==undefined)result[zid]=mins;return result;
    }
    const SPEC_ZONES={'Sub-5K':['Sub-5K'],'5K':['Sub-5K','5K'],'10K':['10K'],'HM':['HM'],'Mara':['Mara']};
    function calcSpecificity(){const today=new Date();const c14=new Date(today);c14.setDate(c14.getDate()-14);const c28=new Date(today);c28.setDate(c28.getDate()-28);const useGAP=(typeof currentMode!=='undefined'&&currentMode==='gap');const zones=useGAP?RACE_PACE_Z:RACE_PW_Z;const modeKey='race';PLANNED_RACES.forEach((tgt,idx)=>{let m14=0,m28=0;const atOrAbove=SPEC_ZONES[tgt.distance_key]||[tgt.distance_key];ZONE_RUNS.forEach(r=>{const d=new Date(r.date);if(d<c28)return;const est=getZoneMins(r,modeKey,zones);let mins=0;atOrAbove.forEach(k=>{mins+=(est[k]||0);});if(d>=c14)m14+=mins;m28+=mins;});const e14=document.getElementById('spec14_'+idx),e28=document.getElementById('spec28_'+idx);if(e14)e14.innerHTML=Math.round(m14)+'<span style="font-size:0.75rem;color:var(--text-dim)">min</span>';if(e28)e28.innerHTML=Math.round(m28)+'<span style="font-size:0.75rem;color:var(--text-dim)">min</span>';});}calcSpecificity();
    // Weekly zone bars
    function weekKey(ds){const d=new Date(ds),day=d.getDay(),m=new Date(d);m.setDate(d.getDate()-((day+6)%7));return m.toISOString().slice(0,10);}
    function fmtWk(s){const d=new Date(s),tmp=new Date(d.valueOf());tmp.setDate(tmp.getDate()+3-(tmp.getDay()+6)%7);const w1=new Date(tmp.getFullYear(),0,4);const wk=1+Math.round(((tmp-w1)/864e5-3+(w1.getDay()+6)%7)/7);return'W'+String(wk).padStart(2,'0')+'/'+String(tmp.getFullYear()).slice(-2);}
    var wkMode='hr',wkN=8;
    function renderWk(){const el=document.getElementById('wk-bars');el.innerHTML='';const zones=zonesFor(wkMode),rm=isRaceMode(wkMode);const weeks={};ZONE_RUNS.forEach(r=>{const w=weekKey(r.date);if(!weeks[w])weeks[w]=[];weeks[w].push(r);});const sorted=Object.keys(weeks).sort().slice(-wkN);let maxT=0;const wd=sorted.map(wk=>{const zm={};zones.forEach(z=>zm[z.id]=0);let t=0;weeks[wk].forEach(r=>{const mins=r.duration_min||0;const est=getZoneMins(r,wkMode,zones);Object.keys(est).forEach(zid=>{if(zm[zid]!==undefined)zm[zid]+=est[zid];});t+=mins;});if(t>maxT)maxT=t;return{week:wk,zm,t};});wd.forEach(w=>{const row=document.createElement('div');row.className='wr';const lbl=document.createElement('div');lbl.className='wl';lbl.textContent=fmtWk(w.week);row.appendChild(lbl);const bar=document.createElement('div');bar.className='wb';zones.forEach(z=>{if(w.zm[z.id]>0){const pct=(w.zm[z.id]/maxT)*100,seg=document.createElement('div');seg.className='ws';seg.style.width=pct+'%';seg.style.background=z.c;seg.innerHTML='<div class="tip">'+z.name+': '+Math.round(w.zm[z.id])+' min</div>';bar.appendChild(seg);}});row.appendChild(bar);const tot=document.createElement('div');tot.className='wt';tot.textContent=Math.round(w.t)+' min';row.appendChild(tot);el.appendChild(row);});document.getElementById('wk-leg').innerHTML=zones.map(z=>'<div class="lg"><div class="lsw" style="background:'+z.c+'"></div>'+z.name+'</div>').join('');}
    function setWM(m,btn){wkMode=m;document.querySelectorAll('#wk-mode button').forEach(b=>b.classList.remove('active'));btn.classList.add('active');renderWk();}
    function setWP(n,btn){wkN=n;document.querySelectorAll('#wk-period button').forEach(b=>b.classList.remove('active'));btn.classList.add('active');renderWk();}
    renderWk();
    // Per-run chart
    var prMode='hr',prChart=null;
    function renderPR(){const ctx=document.getElementById('prChart').getContext('2d');const last30=ZONE_RUNS.slice(-30),zones=zonesFor(prMode),rm=isRaceMode(prMode);const labels=last30.map(r=>{const d=new Date(r.date);return d.getDate()+'/'+(d.getMonth()+1);});const datasets=zones.map((z,zi)=>({label:z.name,data:last30.map(r=>{const mins=r.duration_min||0;const est=getZoneMins(r,prMode,zones);return Math.round(est[z.id]||0);}),backgroundColor:z.c+'cc',borderWidth:0,borderRadius:2}));if(prChart)prChart.destroy();prChart=new Chart(ctx,{type:'bar',data:{labels,datasets},options:{responsive:true,maintainAspectRatio:false,plugins:{legend:{display:false},tooltip:{callbacks:{title:items=>{const i=items[0].dataIndex;return last30[i].name;},label:item=>item.dataset.label+': '+item.raw+' min'}}},scales:{x:{stacked:true,grid:{color:'rgba(255,255,255,0.04)'},ticks:{color:'#8b90a0',font:{size:10,family:"'JetBrains Mono'"}}},y:{stacked:true,grid:{color:'rgba(255,255,255,0.04)'},ticks:{color:'#8b90a0',font:{size:10,family:"'JetBrains Mono'"},callback:v=>v+' min'}}}}});document.getElementById('pr-leg').innerHTML=zones.map(z=>'<div class="lg"><div class="lsw" style="background:'+z.c+'"></div>'+z.name+'</div>').join('');}
    function setPR(m,btn){prMode=m;document.querySelectorAll('#pr-mode button').forEach(b=>b.classList.remove('active'));btn.classList.add('active');try{renderPR();}catch(e){}}
    try{renderPR();var _ps=document.getElementById('pr-static');if(_ps)_ps.style.display='none';var _pc=document.getElementById('pr-canvas-wrap');if(_pc)_pc.style.display='';}catch(e){console.warn('Chart.js required for Per-Run chart:',e);}
    </script>

    
    <!-- RF Trend Chart -->
    <div class="chart-container">
        <div class="chart-header">
            <div class="chart-title">üìà Relative Fitness Level</div>
            <div class="chart-toggle" id="rfToggle">
                <button data-range="90">90d</button>
                <button data-range="180">6m</button>
                <button data-range="365">1yr</button>
                <button data-range="730">2yr</button>
                <button data-range="1095">3yr</button>
                <button data-range="1825">5yr</button>
                <button class="active" data-range="all">All</button>
            </div>
        </div>
        <div class="chart-desc">Blue dots = training, red dots = races, green dashed = easy-run signal.</div>
        <div class="chart-wrapper">
            <canvas id="rfChart"></canvas>
        </div>
    </div>
    
    <!-- RFL 14-day Trend Chart -->
    <div class="chart-container">
        <div class="chart-title">üìà Relative Fitness Level (14 days)</div>
        <div class="chart-desc">Current fitness as % of personal best. Trendline projects 7 days ahead with 95% confidence interval.</div>
        <div class="chart-wrapper" style="height: 180px;">
            <canvas id="rflTrendChart"></canvas>
        </div>
    </div>
    
    <!-- CTL/ATL Chart -->
    <div class="chart-container">
        <div class="chart-header">
            <div class="chart-title">üí™ Training Load</div>
            <div class="chart-toggle" id="ctlAtlToggle">
                <button class="active" data-range="90">90d</button>
                <button data-range="180">6m</button>
                <button data-range="365">1yr</button>
                <button data-range="730">2yr</button>
                <button data-range="1095">3yr</button>
                <button data-range="1825">5yr</button>
            </div>
        </div>
        <div class="chart-desc">CTL (blue) = fitness. ATL (red) = fatigue. Dashed lines show 14-day projection if no training.</div>
        <div class="chart-wrapper">
            <canvas id="ctlAtlChart"></canvas>
        </div>
    </div>
    
    <!-- Volume Chart -->
    <div class="chart-container">
        <div class="chart-header">
            <div class="chart-title">üìÖ Volume</div>
            <div class="chart-toggle" id="volumeGranularityToggle">
                <button class="active" data-granularity="W">W</button>
                <button data-granularity="M">M</button>
                <button data-granularity="Y">Y</button>
            </div>
            <div class="chart-toggle" id="volumeRangeToggle">
                <button class="active" data-range="12">12w</button>
                <button data-range="26">6m</button>
                <button data-range="52">1yr</button>
            </div>
        </div>
        <div class="chart-desc">Distance over time. W=weeks, M=months, Y=years. Consistency matters more than big weeks.</div>
        <div class="chart-wrapper">
            <canvas id="volumeChart"></canvas>
        </div>
    </div>
    
    <!-- v51: Weight Chart (hidden if no weight data) -->
    
    
    <!-- v51: Race Prediction Trend Chart (hidden if no race data) -->
    
    
    <!-- v51: Age Grade Trend Chart (hidden if no age grade data) -->
    
    
    <!-- Recent Runs Table -->
    <div class="chart-container">
        <div class="chart-title-row">
            <span class="chart-title">üèÉ Recent Runs</span>
            <div class="chart-toggle" id="recentRunsToggle">
                <button class="active" data-filter="all">All</button>
                <button data-filter="races">Races</button>
            </div>
        </div>
        <div class="table-wrapper">
        <table id="recentRunsTable">
            <colgroup>
                <col style="width: 13%;">
                <col style="width: 28%;">
                <col style="width: 11%;">
                <col style="width: 11%;">
                <col class="power-only" style="width: 10%;">
                <col style="width: 9%;">
                <col style="width: 9%;">
                <col style="width: 9%;">
            </colgroup>
            <thead>
                <tr>
                    <th>Date</th>
                    <th>Activity</th>
                    <th>Dist</th>
                    <th>Pace</th>
                    <th class="power-only">nPwr</th>
                    <th>HR</th>
                    <th>TSS</th>
                    <th>RFL%</th>
                </tr>
            </thead>
            <tbody id="recentRunsBody">
            </tbody>
        </table>
        </div>
    </div>
    
    <!-- Top Races Section (hidden if no race data) -->
    
    
    <div class="footer">
        Updated: 2026-02-20 07:39<br>
        Data through: 2026-02-20
    </div>
    
    <script>
        // RFL 14-day Trend Chart with trendline, 7-day projection and 95% CI
        const rflTrendCtx = document.getElementById('rflTrendChart').getContext('2d');
        const rfl14Data = {
            stryd: { values: [100, 100, null, null, null, null, null, null, null], trendline: [100.0, 100.0, null, null, null, null, null, null, null], projection: [null, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0], ci_upper: [null, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0], ci_lower: [null, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0] },
            gap: { values: [100, 100, null, null, null, null, null, null, null], trendline: [100.0, 100.0, null, null, null, null, null, null, null], projection: [null, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0], ci_upper: [null, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0], ci_lower: [null, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0] },
            sim: { values: [100, 100, null, null, null, null, null, null, null], trendline: [100.0, 100.0, null, null, null, null, null, null, null], projection: [null, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0], ci_upper: [null, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0], ci_lower: [null, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0] }
        };
        let rfl14Chart = new Chart(rflTrendCtx, {
            type: 'line',
            data: {
                labels: ["19 Feb", "20 Feb", "21 Feb", "22 Feb", "23 Feb", "24 Feb", "25 Feb", "26 Feb", "27 Feb"],
                datasets: [{
                    label: 'RFL vs peak',
                    data: [100, 100, null, null, null, null, null, null, null],
                    borderColor: 'rgba(129, 140, 248, 1)',
                    backgroundColor: 'rgba(129, 140, 248, 0.1)',
                    borderWidth: 2,
                    pointRadius: 3,
                    pointBackgroundColor: 'rgba(129, 140, 248, 1)',
                    fill: false,
                    tension: 0,
                    order: 1,
                }, {
                    label: 'Trendline',
                    data: [100.0, 100.0, null, null, null, null, null, null, null],
                    borderColor: 'rgba(100, 100, 100, 0.6)',
                    borderWidth: 1,
                    borderDash: [5, 5],
                    pointRadius: 0,
                    fill: false,
                    tension: 0,
                    order: 2,
                }, {
                    label: 'Projection',
                    data: [null, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0],
                    borderColor: 'rgba(239, 68, 68, 0.9)',
                    borderWidth: 2,
                    pointRadius: 0,
                    fill: false,
                    tension: 0,
                    order: 3,
                }, {
                    label: '95% CI upper',
                    data: [null, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0],
                    borderColor: 'rgba(239, 68, 68, 0.5)',
                    borderWidth: 1,
                    borderDash: [2, 2],
                    pointRadius: 0,
                    fill: false,
                    tension: 0,
                    order: 4,
                }, {
                    label: '95% CI lower',
                    data: [null, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0],
                    borderColor: 'rgba(239, 68, 68, 0.5)',
                    borderWidth: 1,
                    borderDash: [2, 2],
                    pointRadius: 0,
                    fill: '-1',
                    backgroundColor: 'rgba(239, 68, 68, 0.12)',
                    tension: 0,
                    order: 5,
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: true,
                        position: 'bottom',
                        labels: {
                            boxWidth: 10,
                            usePointStyle: true,
                            padding: 4,
                            font: { size: 10 },
                            filter: function(item) {
                                // Hide CI labels from legend
                                return !item.text.includes('CI');
                            }
                        }
                    },
                    annotation: { annotations: raceAnnotations(["19 Feb", "20 Feb", "21 Feb", "22 Feb", "23 Feb", "24 Feb", "25 Feb", "26 Feb", "27 Feb"]) }
                },
                scales: {
                    x: {
                        display: true,
                        ticks: {
                            maxTicksLimit: 7,
                            font: { size: 10 }
                        }
                    },
                    y: {
                        display: true,
                        grace: '10%',
                        ticks: {
                            font: { size: 10 },
                            callback: function(value) { return value + '%'; }
                        },
                        suggestedMin: Math.min(...[100, 100, null, null, null, null, null, null, null].filter(v => v !== null)) - 5,
                        suggestedMax: Math.max(...[100, 100, null, null, null, null, null, null, null].filter(v => v !== null)) + 5
                    }
                }
            }
        });
        
        function updateRfl14Chart(mode) {
            const d = rfl14Data[mode] || rfl14Data.stryd;
            const modeColors = {
                stryd: { main: 'rgba(129, 140, 248, 1)', bg: 'rgba(129, 140, 248, 0.1)', point: 'rgba(129, 140, 248, 1)' },
                gap: { main: 'rgba(74, 222, 128, 1)', bg: 'rgba(74, 222, 128, 0.1)', point: 'rgba(74, 222, 128, 1)' },
                sim: { main: 'rgba(249, 115, 22, 1)', bg: 'rgba(249, 115, 22, 0.1)', point: 'rgba(249, 115, 22, 1)' }
            };
            const mc = modeColors[mode] || modeColors.stryd;
            rfl14Chart.data.datasets[0].data = d.values;
            rfl14Chart.data.datasets[0].borderColor = mc.main;
            rfl14Chart.data.datasets[0].backgroundColor = mc.bg;
            rfl14Chart.data.datasets[0].pointBackgroundColor = mc.point;
            rfl14Chart.data.datasets[1].data = d.trendline;
            rfl14Chart.data.datasets[2].data = d.projection;
            rfl14Chart.data.datasets[3].data = d.ci_upper;
            rfl14Chart.data.datasets[4].data = d.ci_lower;
            // Update y-axis range
            const vals = d.values.filter(v => v !== null);
            if (vals.length > 0) {
                rfl14Chart.options.scales.y.suggestedMin = Math.min(...vals) - 5;
                rfl14Chart.options.scales.y.suggestedMax = Math.max(...vals) + 5;
            }
            rfl14Chart.update();
        }

        // RF Trend Chart - with toggle (v51: includes Easy RF EMA + race dots)
        const rfData = {
            '90': { dates: ["19 Feb 26"], values: [100], trend: [100], easy: [100.0], races: [0], gap_trend: [100], sim_trend: [100], gap_values: [100], sim_values: [100] },
            '180': { dates: ["19 Feb 26"], values: [100], trend: [100], easy: [100.0], races: [0], gap_trend: [100], sim_trend: [100], gap_values: [100], sim_values: [100] },
            '365': { dates: ["19 Feb 26"], values: [100], trend: [100], easy: [100.0], races: [0], gap_trend: [100], sim_trend: [100], gap_values: [100], sim_values: [100] },
            '730': { dates: ["19 Feb 26"], values: [100], trend: [100], easy: [100.0], races: [0], gap_trend: [100], sim_trend: [100], gap_values: [100], sim_values: [100] },
            '1095': { dates: ["19 Feb 26"], values: [100], trend: [100], easy: [100.0], races: [0], gap_trend: [100], sim_trend: [100], gap_values: [100], sim_values: [100] },
            '1825': { dates: ["19 Feb 26"], values: [100], trend: [100], easy: [100.0], races: [0], gap_trend: [100], sim_trend: [100], gap_values: [100], sim_values: [100] },
            'all': { dates: ["19 Feb 26"], values: [100], trend: [100], easy: [100.0], races: [0], gap_trend: [100], sim_trend: [100], gap_values: [100], sim_values: [100] }
        };
        
        // Phase 2: Mode state (must be declared before functions that reference it)
        let currentMode = 'gap';
        
        // Phase 2: Mode data for stats switching
        const modeStats = {
            stryd: { rfl: '100', ag: '6.4',
                rflDelta: '-',
                cp: 300,
                pred5k: '3:57:17',
                pred10k: '8:18:17',
                predHm: '18:26:35',
                predMara: '39:22:22',
                pred5k_s: 14237,
                pred10k_s: 29897,
                predHm_s: 66395,
                predMara_s: 141742 },
            gap: { rfl: '100', ag: '81.6',
                rflDelta: '-',
                cp: 300,
                pred5k: '18:29',
                pred10k: '38:48',
                predHm: '1:26:11',
                predMara: '3:03:59',
                pred5k_s: 1109,
                pred10k_s: 2328,
                predHm_s: 5171,
                predMara_s: 11039 },
            sim: { rfl: '100', ag: '6.4',
                rflDelta: '-',
                cp: 300,
                pred5k: '3:57:17',
                pred10k: '8:18:17',
                predHm: '18:26:35',
                predMara: '39:22:22',
                pred5k_s: 14237,
                pred10k_s: 29897,
                predHm_s: 66395,
                predMara_s: 141742 }
        };
        
        // Re-render alert banner now that modeStats is available (for CP display)
        if (typeof renderAlertBanner === 'function') renderAlertBanner(currentMode);
        
        // v51: Generate per-point colours (red for races, blue for training)
        function racePointColors(races, baseColor, raceColor) {
            return races.map(r => r === 1 ? raceColor : baseColor);
        }
        
        const rfCtx = document.getElementById('rfChart').getContext('2d');
        let rfChart = new Chart(rfCtx, {
            type: 'line',
            data: {
                labels: rfData['all'].dates,
                datasets: [{
                    label: 'RFL',
                    data: rfData['all'].values,
                    borderColor: 'rgba(129, 140, 248, 0.1)',
                    backgroundColor: 'rgba(129, 140, 248, 0.1)',
                    borderWidth: 1,
                    pointRadius: 0,
                    pointBackgroundColor: 'rgba(129, 140, 248, 0.15)',
                    pointBorderColor: 'rgba(129, 140, 248, 0.1)',
                    pointBorderWidth: 1,
                    fill: false,
                    tension: 0.2,
                }, {
                    label: 'RFL Trend',
                    data: rfData['all'].trend,
                    borderColor: 'rgba(129, 140, 248, 1)',
                    borderWidth: 2,
                    pointRadius: 0,
                    fill: false,
                    tension: 0.3,
                }, {
                    label: 'Easy RF',
                    data: rfData['all'].easy,
                    borderColor: 'rgba(34, 197, 94, 0.8)',
                    borderWidth: 1.5,
                    borderDash: [4, 3],
                    pointRadius: 0,
                    fill: false,
                    tension: 0.3,
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: { intersect: false, mode: 'index' },
                plugins: {
                    legend: {
                        display: true,
                        position: 'bottom',
                        labels: { 
                            boxWidth: 12, padding: 8, font: { size: 10 }, usePointStyle: true,
                            generateLabels: function(chart) {
                                const mc = typeof currentMode !== 'undefined' ? currentMode : 'stryd';
                                const colors = {
                                    stryd: { fill: 'rgba(129, 140, 248, ', trend: '#818cf8' },
                                    gap: { fill: 'rgba(74, 222, 128, ', trend: '#4ade80' },
                                    sim: { fill: 'rgba(249, 115, 22, ', trend: '#f97316' }
                                };
                                const c = colors[mc] || colors.stryd;
                                const modeLabel = mc === 'gap' ? 'RFL (GAP)' : mc === 'sim' ? 'RFL (Sim)' : 'RFL';
                                const trendLabel = mc === 'gap' ? 'GAP Trend' : mc === 'sim' ? 'Sim Trend' : 'RFL Trend';
                                const items = [
                                    { text: modeLabel, fillStyle: c.fill + '0.4)', strokeStyle: c.fill + '0.3)', pointStyle: 'circle', hidden: !chart.isDatasetVisible(0), datasetIndex: 0, fontColor: '#8b90a0' },
                                    { text: trendLabel, fillStyle: c.trend, strokeStyle: c.trend, pointStyle: 'circle', hidden: !chart.isDatasetVisible(1), datasetIndex: 1, fontColor: '#8b90a0' }
                                ];
                                if (mc === 'stryd') {
                                    items.push({ text: 'Easy RF', fillStyle: 'rgba(34, 197, 94, 0.8)', strokeStyle: 'rgba(34, 197, 94, 0.8)', pointStyle: 'circle', hidden: !chart.isDatasetVisible(2), datasetIndex: 2, fontColor: '#8b90a0' });
                                }
                                return items;
                            }
                        }
                    }
                },
                scales: {
                    x: { display: true, ticks: { maxTicksLimit: 12, maxRotation: 0, font: { size: 10 } } },
                    y: { 
                        display: true, 
                        ticks: { 
                            font: { size: 10 },
                            callback: function(value) { return value + '%'; }
                        },
                        min: 50,
                        suggestedMax: 100
                    }
                }
            }
        });
        
        let currentRfRange = 'all';
        
        function updateRfChart(range) {
            currentRfRange = range;
            const d = rfData[range];
            // Mode-dependent data selection
            const valKey = currentMode === 'gap' ? 'gap_values' : currentMode === 'sim' ? 'sim_values' : 'values';
            const trendKey = currentMode === 'gap' ? 'gap_trend' : currentMode === 'sim' ? 'sim_trend' : 'trend';
            rfChart.data.labels = d.dates;
            rfChart.data.datasets[0].data = d[valKey] || d.values;
            rfChart.data.datasets[1].data = d[trendKey] || d.trend;
            rfChart.data.datasets[2].data = currentMode === 'stryd' ? d.easy : d.easy.map(() => null);
            
            // Adjust display based on range
            const pointSettings = {
                '90': { radius: 3, borderColor: 'rgba(129, 140, 248, 0.3)', pointColor: 'rgba(129, 140, 248, 0.5)', fill: false, tension: 0, lineWidth: 1, yMin: 70, ticks: 5 },
                '180': { radius: 2, borderColor: 'rgba(129, 140, 248, 0.25)', pointColor: 'rgba(129, 140, 248, 0.4)', fill: false, tension: 0, lineWidth: 1, yMin: 70, ticks: 5 },
                '365': { radius: 1.5, borderColor: 'rgba(129, 140, 248, 0.2)', pointColor: 'rgba(129, 140, 248, 0.3)', fill: false, tension: 0, lineWidth: 1, yMin: 70, ticks: 8 },
                '730': { radius: 1, borderColor: 'rgba(129, 140, 248, 0.15)', pointColor: 'rgba(129, 140, 248, 0.25)', fill: false, tension: 0.1, lineWidth: 1, yMin: 60, ticks: 10 },
                '1095': { radius: 0.5, borderColor: 'rgba(129, 140, 248, 0.1)', pointColor: 'rgba(129, 140, 248, 0.2)', fill: false, tension: 0.1, lineWidth: 1, yMin: 50, ticks: 10 },
                '1825': { radius: 0, borderColor: 'rgba(129, 140, 248, 0.1)', pointColor: 'rgba(129, 140, 248, 0.15)', fill: false, tension: 0.2, lineWidth: 1, yMin: 50, ticks: 10 },
                'all': { radius: 0, borderColor: 'rgba(129, 140, 248, 0.1)', pointColor: 'rgba(129, 140, 248, 0.15)', fill: false, tension: 0.2, lineWidth: 1, yMin: 50, ticks: 12 }
            };
            const settings = pointSettings[range];
            const races = d.races;
            // Mode colors
            const modeColors = {
                stryd: { base: 'rgba(129, 140, 248, ', trend: '#818cf8' },
                gap: { base: 'rgba(74, 222, 128, ', trend: '#4ade80' },
                sim: { base: 'rgba(249, 115, 22, ', trend: '#f97316' }
            };
            const mc = modeColors[currentMode];
            rfChart.data.datasets[0].pointRadius = settings.radius;
            rfChart.data.datasets[0].pointBackgroundColor = races.length ? racePointColors(races, mc.base + '0.5)', 'rgba(239, 68, 68, 0.9)') : mc.base + '0.5)';
            rfChart.data.datasets[0].pointBorderColor = races.length ? racePointColors(races, mc.base + '0.3)', 'rgba(239, 68, 68, 0.7)') : mc.base + '0.3)';
            rfChart.data.datasets[0].borderColor = mc.base + '0.15)';
            rfChart.data.datasets[0].borderWidth = settings.lineWidth;
            rfChart.data.datasets[0].fill = settings.fill;
            rfChart.data.datasets[0].tension = settings.tension;
            rfChart.data.datasets[1].borderColor = mc.trend;
            rfChart.options.scales.y.min = settings.yMin;
            rfChart.options.scales.x.ticks.maxTicksLimit = settings.ticks;
            
            rfChart.update();
        }
        
        document.getElementById('rfToggle').addEventListener('click', function(e) {
            if (e.target.tagName === 'BUTTON') {
                const range = e.target.dataset.range;
                this.querySelectorAll('button').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                updateRfChart(range);
            }
        });
        
        // CTL/ATL Training Load Chart - with toggle
        const ctlAtlData = {
            '90': { dates: ["19 Feb 26", "20 Feb 26", "21 Feb 26", "22 Feb 26", "23 Feb 26", "24 Feb 26", "25 Feb 26", "26 Feb 26", "27 Feb 26", "28 Feb 26", "01 Mar 26", "02 Mar 26", "03 Mar 26", "04 Mar 26", "05 Mar 26"], ctl: [1.8, null, null, null, null, null, null, null, null, null, null, null, null, null, null], atl: [10.8, null, null, null, null, null, null, null, null, null, null, null, null, null, null], ctlProj: [1.8, 1.8, 1.7, 1.7, 1.6, 1.6, 1.6, 1.5, 1.5, 1.4, 1.4, 1.4, 1.3, 1.3, 1.3], atlProj: [10.8, 9.2, 7.9, 6.8, 5.8, 5.0, 4.3, 3.7, 3.1, 2.7, 2.3, 2.0, 1.7, 1.5, 1.2] },
            '180': { dates: ["19 Feb 26", "20 Feb 26", "21 Feb 26", "22 Feb 26", "23 Feb 26", "24 Feb 26", "25 Feb 26", "26 Feb 26", "27 Feb 26", "28 Feb 26", "01 Mar 26", "02 Mar 26", "03 Mar 26", "04 Mar 26", "05 Mar 26"], ctl: [1.8, null, null, null, null, null, null, null, null, null, null, null, null, null, null], atl: [10.8, null, null, null, null, null, null, null, null, null, null, null, null, null, null], ctlProj: [1.8, 1.8, 1.7, 1.7, 1.6, 1.6, 1.6, 1.5, 1.5, 1.4, 1.4, 1.4, 1.3, 1.3, 1.3], atlProj: [10.8, 9.2, 7.9, 6.8, 5.8, 5.0, 4.3, 3.7, 3.1, 2.7, 2.3, 2.0, 1.7, 1.5, 1.2] },
            '365': { dates: ["19 Feb 26", "20 Feb 26", "21 Feb 26", "22 Feb 26", "23 Feb 26", "24 Feb 26", "25 Feb 26", "26 Feb 26", "27 Feb 26", "28 Feb 26", "01 Mar 26", "02 Mar 26", "03 Mar 26", "04 Mar 26", "05 Mar 26"], ctl: [1.8, null, null, null, null, null, null, null, null, null, null, null, null, null, null], atl: [10.8, null, null, null, null, null, null, null, null, null, null, null, null, null, null], ctlProj: [1.8, 1.8, 1.7, 1.7, 1.6, 1.6, 1.6, 1.5, 1.5, 1.4, 1.4, 1.4, 1.3, 1.3, 1.3], atlProj: [10.8, 9.2, 7.9, 6.8, 5.8, 5.0, 4.3, 3.7, 3.1, 2.7, 2.3, 2.0, 1.7, 1.5, 1.2] },
            '730': { dates: ["19 Feb 26", "20 Feb 26", "21 Feb 26", "22 Feb 26", "23 Feb 26", "24 Feb 26", "25 Feb 26", "26 Feb 26", "27 Feb 26", "28 Feb 26", "01 Mar 26", "02 Mar 26", "03 Mar 26", "04 Mar 26", "05 Mar 26"], ctl: [1.8, null, null, null, null, null, null, null, null, null, null, null, null, null, null], atl: [10.8, null, null, null, null, null, null, null, null, null, null, null, null, null, null], ctlProj: [1.8, 1.8, 1.7, 1.7, 1.6, 1.6, 1.6, 1.5, 1.5, 1.4, 1.4, 1.4, 1.3, 1.3, 1.3], atlProj: [10.8, 9.2, 7.9, 6.8, 5.8, 5.0, 4.3, 3.7, 3.1, 2.7, 2.3, 2.0, 1.7, 1.5, 1.2] },
            '1095': { dates: ["19 Feb 26", "20 Feb 26", "21 Feb 26", "22 Feb 26", "23 Feb 26", "24 Feb 26", "25 Feb 26", "26 Feb 26", "27 Feb 26", "28 Feb 26", "01 Mar 26", "02 Mar 26", "03 Mar 26", "04 Mar 26", "05 Mar 26"], ctl: [1.8, null, null, null, null, null, null, null, null, null, null, null, null, null, null], atl: [10.8, null, null, null, null, null, null, null, null, null, null, null, null, null, null], ctlProj: [1.8, 1.8, 1.7, 1.7, 1.6, 1.6, 1.6, 1.5, 1.5, 1.4, 1.4, 1.4, 1.3, 1.3, 1.3], atlProj: [10.8, 9.2, 7.9, 6.8, 5.8, 5.0, 4.3, 3.7, 3.1, 2.7, 2.3, 2.0, 1.7, 1.5, 1.2] },
            '1825': { dates: ["19 Feb 26", "20 Feb 26", "21 Feb 26", "22 Feb 26", "23 Feb 26", "24 Feb 26", "25 Feb 26", "26 Feb 26", "27 Feb 26", "28 Feb 26", "01 Mar 26", "02 Mar 26", "03 Mar 26", "04 Mar 26", "05 Mar 26"], ctl: [1.8, null, null, null, null, null, null, null, null, null, null, null, null, null, null], atl: [10.8, null, null, null, null, null, null, null, null, null, null, null, null, null, null], ctlProj: [1.8, 1.8, 1.7, 1.7, 1.6, 1.6, 1.6, 1.5, 1.5, 1.4, 1.4, 1.4, 1.3, 1.3, 1.3], atlProj: [10.8, 9.2, 7.9, 6.8, 5.8, 5.0, 4.3, 3.7, 3.1, 2.7, 2.3, 2.0, 1.7, 1.5, 1.2] }
        };
        
        const ctlAtlCtx = document.getElementById('ctlAtlChart').getContext('2d');
        let ctlAtlChart = new Chart(ctlAtlCtx, {
            type: 'line',
            data: {
                labels: ctlAtlData['90'].dates,
                datasets: [{
                    label: 'CTL (Fitness)',
                    data: ctlAtlData['90'].ctl,
                    borderColor: 'rgba(129, 140, 248, 1)',
                    backgroundColor: 'rgba(129, 140, 248, 0.1)',
                    borderWidth: 2,
                    pointRadius: 0,
                    fill: false,
                    tension: 0.3,
                }, {
                    label: 'ATL (Fatigue)',
                    data: ctlAtlData['90'].atl,
                    borderColor: 'rgba(239, 68, 68, 1)',
                    backgroundColor: 'rgba(239, 68, 68, 0.12)',
                    borderWidth: 2,
                    pointRadius: 0,
                    fill: false,
                    tension: 0.3,
                }, {
                    label: 'CTL Projection',
                    data: ctlAtlData['90'].ctlProj,
                    borderColor: 'rgba(129, 140, 248, 0.5)',
                    borderWidth: 2,
                    borderDash: [5, 5],
                    pointRadius: 0,
                    fill: false,
                    tension: 0.3,
                }, {
                    label: 'ATL Projection',
                    data: ctlAtlData['90'].atlProj,
                    borderColor: 'rgba(239, 68, 68, 0.5)',
                    borderWidth: 2,
                    borderDash: [5, 5],
                    pointRadius: 0,
                    fill: false,
                    tension: 0.3,
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: { intersect: false, mode: 'index' },
                plugins: {
                    legend: {
                        display: true,
                        position: 'bottom',
                        labels: { 
                            boxWidth: 12, 
                            padding: 8, 
                            font: { size: 10 },
                            usePointStyle: true,
                            filter: function(item) {
                                // Hide projection labels from legend
                                return !item.text.includes('Projection');
                            }
                        }
                    },
                    annotation: { annotations: raceAnnotations(ctlAtlData['90'].dates) }
                },
                scales: {
                    x: { display: true, ticks: { maxTicksLimit: 5, maxRotation: 0, font: { size: 10 } } },
                    y: { display: true, ticks: { font: { size: 10 } } }
                }
            }
        });
        
        document.getElementById('ctlAtlToggle').addEventListener('click', function(e) {
            if (e.target.tagName === 'BUTTON') {
                const range = e.target.dataset.range;
                this.querySelectorAll('button').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                ctlAtlChart.data.labels = ctlAtlData[range].dates;
                ctlAtlChart.data.datasets[0].data = ctlAtlData[range].ctl;
                ctlAtlChart.data.datasets[1].data = ctlAtlData[range].atl;
                ctlAtlChart.data.datasets[2].data = ctlAtlData[range].ctlProj;
                ctlAtlChart.data.datasets[3].data = ctlAtlData[range].atlProj;
                ctlAtlChart.options.plugins.annotation = { annotations: raceAnnotations(ctlAtlData[range].dates) };
                ctlAtlChart.update();
            }
        });
        
        // Volume Chart - with two-level toggle (granularity + range)
        const volumeData = {
            'W': {
                '12': { labels: ["16 Feb"], distances: [11.9], runs: [1] },
                '26': { labels: ["16 Feb"], distances: [11.9], runs: [1] },
                '52': { labels: ["16 Feb"], distances: [11.9], runs: [1] }
            },
            'M': {
                '6': { labels: ["Feb 26"], distances: [11.9], runs: [1] },
                '12': { labels: ["Feb 26"], distances: [11.9], runs: [1] },
                '24': { labels: ["Feb 26"], distances: [11.9], runs: [1] },
                'All': { labels: ["Feb 26"], distances: [11.9], runs: [1] }
            },
            'Y': {
                '3': { labels: ["To 21/02/24", "To 20/02/25", "To 20/02/26"], distances: [0, 0, 12.0], runs: [0, 0, 1] },
                '5': { labels: ["To 21/02/22", "To 21/02/23", "To 21/02/24", "To 20/02/25", "To 20/02/26"], distances: [0, 0, 0, 0, 12.0], runs: [0, 0, 0, 0, 1] },
                'All': { labels: ["2026"], distances: [12.0], runs: [1] }
            }
        };
        
        const volumeRangeOptions = {
            'W': ['12', '26', '52'],
            'M': ['6', '12', '24', 'All'],
            'Y': ['3', '5', 'All']
        };
        
        let currentGranularity = 'W';
        let currentRange = '12';
        
        const volCtx = document.getElementById('volumeChart').getContext('2d');
        let volChart = new Chart(volCtx, {
            type: 'bar',
            data: {
                labels: volumeData['W']['12'].labels,
                datasets: [{
                    label: 'Distance (km)',
                    data: volumeData['W']['12'].distances,
                    backgroundColor: 'rgba(129, 140, 248, 0.7)',
                    borderRadius: 4,
                }]
            },
            plugins: [ChartDataLabels],
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        callbacks: {
                            afterLabel: function(context) {
                                const runs = volumeData[currentGranularity][currentRange].runs;
                                return runs[context.dataIndex] + ' runs';
                            }
                        }
                    },
                    datalabels: {
                        display: function(context) {
                            return context.dataset.data.length <= 20;
                        },
                        anchor: 'end',
                        align: 'end',
                        offset: -4,
                        color: '#c0c4d0',
                        font: { size: 10, weight: '500' },
                        formatter: function(value) {
                            return Math.round(value);
                        }
                    }
                },
                scales: {
                    x: { ticks: { font: { size: 10 }, maxTicksLimit: 12 } },
                    y: { beginAtZero: true, ticks: { font: { size: 10 } }, grace: '5%' }
                }
            }
        });
        
        function updateVolumeRangeButtons() {
            const rangeToggle = document.getElementById('volumeRangeToggle');
            const options = volumeRangeOptions[currentGranularity];
            rangeToggle.innerHTML = options.map((opt, idx) => 
                `<button ${idx === 0 ? 'class="active"' : ''} data-range="${opt}">${opt}</button>`
            ).join('');
            currentRange = options[0];
        }
        
        function updateVolumeChart() {
            const data = volumeData[currentGranularity][currentRange];
            volChart.data.labels = data.labels;
            volChart.data.datasets[0].data = data.distances;
            volChart.update();
        }
        
        document.getElementById('volumeGranularityToggle').addEventListener('click', function(e) {
            if (e.target.tagName === 'BUTTON') {
                currentGranularity = e.target.dataset.granularity;
                this.querySelectorAll('button').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                updateVolumeRangeButtons();
                updateVolumeChart();
            }
        });
        
        document.getElementById('volumeRangeToggle').addEventListener('click', function(e) {
            if (e.target.tagName === 'BUTTON') {
                currentRange = e.target.dataset.range;
                this.querySelectorAll('button').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                updateVolumeChart();
            }
        });
        
        // All-time Weekly RFL Chart
        // CTL/ATL/TSB live update based on current date
        const ctlAtlLookup = {"2026-02-19": {"ctl": 1.8, "atl": 10.8, "tsb": -9.0}, "2026-02-20": {"ctl": 1.8, "atl": 9.2, "tsb": -7.5}, "2026-02-21": {"ctl": 1.7, "atl": 7.9, "tsb": -6.2}, "2026-02-22": {"ctl": 1.7, "atl": 6.8, "tsb": -5.1}, "2026-02-23": {"ctl": 1.6, "atl": 5.8, "tsb": -4.2}, "2026-02-24": {"ctl": 1.6, "atl": 5.0, "tsb": -3.4}, "2026-02-25": {"ctl": 1.6, "atl": 4.3, "tsb": -2.7}, "2026-02-26": {"ctl": 1.5, "atl": 3.7, "tsb": -2.1}, "2026-02-27": {"ctl": 1.5, "atl": 3.1, "tsb": -1.7}, "2026-02-28": {"ctl": 1.4, "atl": 2.7, "tsb": -1.2}, "2026-03-01": {"ctl": 1.4, "atl": 2.3, "tsb": -0.9}, "2026-03-02": {"ctl": 1.4, "atl": 2.0, "tsb": -0.6}, "2026-03-03": {"ctl": 1.3, "atl": 1.7, "tsb": -0.3}, "2026-03-04": {"ctl": 1.3, "atl": 1.5, "tsb": -0.1}, "2026-03-05": {"ctl": 1.3, "atl": 1.2, "tsb": 0.0}, "2026-03-06": {"ctl": 1.3, "atl": 1.1, "tsb": 0.2}, "2026-03-07": {"ctl": 1.2, "atl": 0.9, "tsb": 0.3}, "2026-03-08": {"ctl": 1.2, "atl": 0.8, "tsb": 0.4}, "2026-03-09": {"ctl": 1.2, "atl": 0.7, "tsb": 0.5}, "2026-03-10": {"ctl": 1.1, "atl": 0.6, "tsb": 0.6}, "2026-03-11": {"ctl": 1.1, "atl": 0.5, "tsb": 0.6}, "2026-03-12": {"ctl": 1.1, "atl": 0.4, "tsb": 0.7}, "2026-03-13": {"ctl": 1.1, "atl": 0.4, "tsb": 0.7}, "2026-03-14": {"ctl": 1.0, "atl": 0.3, "tsb": 0.7}, "2026-03-15": {"ctl": 1.0, "atl": 0.3, "tsb": 0.7}, "2026-03-16": {"ctl": 1.0, "atl": 0.2, "tsb": 0.8}, "2026-03-17": {"ctl": 1.0, "atl": 0.2, "tsb": 0.8}, "2026-03-18": {"ctl": 0.9, "atl": 0.2, "tsb": 0.8}, "2026-03-19": {"ctl": 0.9, "atl": 0.1, "tsb": 0.8}, "2026-03-20": {"ctl": 0.9, "atl": 0.1, "tsb": 0.8}, "2026-03-21": {"ctl": 0.9, "atl": 0.1, "tsb": 0.8}};
        
        function updateCtlAtl() {
            const today = new Date();
            const dateStr = today.toISOString().split('T')[0];
            
            if (ctlAtlLookup[dateStr]) {
                const data = ctlAtlLookup[dateStr];
                if (data.ctl !== null) document.getElementById('ctl-value').textContent = data.ctl;
                if (data.atl !== null) document.getElementById('atl-value').textContent = data.atl;
                if (data.tsb !== null) document.getElementById('tsb-value').textContent = data.tsb;
            }
        }
        
        // Update on page load
        updateCtlAtl();
        
        // Top Races data and toggle
        const topRacesData = {"1y": [], "2y": [], "3y": [], "5y": [], "all": []};
        
        function updateTopRacesTable(period) {
            const tbody = document.getElementById('topRacesBody');
            if (!tbody) return;
            const races = (topRacesData[period] || []).slice();
            
            if (races.length === 0) {
                tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; color: var(--text-dim);">No races in this period</td></tr>';
                return;
            }
            
            // Sort by mode-appropriate RFL descending
            const rflKey = currentMode === 'gap' ? 'rfl_gap' : currentMode === 'sim' ? 'rfl_sim' : 'rfl';
            races.sort((a, b) => (b[rflKey] || 0) - (a[rflKey] || 0));
            
            tbody.innerHTML = races.map((race, idx) => {
                const rflVal = race[rflKey] || '-';
                return `
                <tr>
                    <td>${race.date}</td>
                    <td>${race.name}</td>
                    <td>${race.dist ? race.dist + ' km' : '-'}</td>
                    <td>${race.time}</td>
                    <td>${race.ag ? race.ag + '%' : '-'}</td>
                    <td>${rflVal}</td>
                </tr>`;
            }).join('');
        }
        
        // Initialize with 1 year view
        if (document.getElementById('topRacesBody')) {
            updateTopRacesTable('1y');
        }
        
        // Toggle handler
        const topRacesToggleEl = document.getElementById('topRacesToggle');
        if (topRacesToggleEl) {
            topRacesToggleEl.addEventListener('click', function(e) {
            if (e.target.tagName === 'BUTTON') {
                this.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
                e.target.classList.add('active');
                const period = e.target.getAttribute('data-period');
                updateTopRacesTable(period);
            }
        });
        }
        
        // --- v51: Weight Chart ---
        const weightAllDates = [];
        const weightAllValues = [];
        
        function getWeightSlice(months) {
            if (months >= 999) return { dates: weightAllDates, values: weightAllValues };
            const n = Math.round(months * 4.33);  // ~weeks per month
            return {
                dates: weightAllDates.slice(-n),
                values: weightAllValues.slice(-n)
            };
        }
        
        const weightCtx = document.getElementById('weightChart');
        let weightChart = null;
        if (weightCtx && weightAllDates.length > 0) {
            const w6 = getWeightSlice(6);
            weightChart = new Chart(weightCtx.getContext('2d'), {
                type: 'line',
                data: {
                    labels: w6.dates,
                    datasets: [{
                        label: 'Weight (kg)',
                        data: w6.values,
                        borderColor: 'rgba(168, 85, 247, 0.9)',
                        backgroundColor: 'rgba(168, 85, 247, 0.1)',
                        borderWidth: 1.5,
                        pointRadius: 1,
                        fill: true,
                        tension: 0.3,
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        x: { display: true, ticks: { maxTicksLimit: 5, maxRotation: 0, font: { size: 10 } } },
                        y: { 
                            display: true, 
                            ticks: { font: { size: 10 }, callback: function(v) { return v + 'kg'; } }
                        }
                    }
                }
            });
            
            document.getElementById('weightToggle').addEventListener('click', function(e) {
                if (e.target.tagName === 'BUTTON') {
                    this.querySelectorAll('button').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    const months = parseInt(e.target.dataset.months);
                    const wd = getWeightSlice(months);
                    weightChart.data.labels = wd.dates;
                    weightChart.data.datasets[0].data = wd.values;
                    weightChart.update();
                }
            });
        }
        
        // --- v51: Race Prediction Trend Chart ---
        const predData = {"5k": {"dates": [], "dates_iso": [], "predicted": [], "actual": [], "is_parkrun": [], "names": [], "temps": [], "surfaces": [], "temp_adjs": [], "surface_adjs": []}, "10k": {"dates": [], "dates_iso": [], "predicted": [], "actual": [], "is_parkrun": [], "names": [], "temps": [], "surfaces": [], "temp_adjs": [], "surface_adjs": []}, "hm": {"dates": [], "dates_iso": [], "predicted": [], "actual": [], "is_parkrun": [], "names": [], "temps": [], "surfaces": [], "temp_adjs": [], "surface_adjs": []}, "marathon": {"dates": [], "dates_iso": [], "predicted": [], "actual": [], "is_parkrun": [], "names": [], "temps": [], "surfaces": [], "temp_adjs": [], "surface_adjs": []}};
        let currentPredDist = '5k';
        let showParkruns = false;
        let adjustConditions = false;
        
        // Heat scaling constants (match StepB)
        const HEAT_REF_MINS = 90.0;
        const HEAT_MAX_MULT = 1.5;
        
        function formatPredTime(seconds) {
            if (!seconds) return '-';
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            if (h > 0) return h + ':' + String(m).padStart(2, '0') + ':' + String(s).padStart(2, '0');
            return m + ':' + String(s).padStart(2, '0');
        }
        
        const predCtx = document.getElementById('predChart');
        let predChart = null;
        
        function renderPredChart(distKey, includeParkruns) {
            if (!predCtx) return;
            const d = predData[distKey];
            if (!d || !d.dates || d.dates.length === 0) return;
            
            // Filter by parkrun toggle
            const indices = [];
            for (let i = 0; i < d.dates.length; i++) {
                if (!includeParkruns && d.is_parkrun[i] === 1) continue;
                indices.push(i);
            }
            
            const dates = indices.map(i => d.dates[i]);
            const datesISO = indices.map(i => d.dates_iso[i]);
            // Mode-dependent prediction source
            const predKey = currentMode === 'gap' ? 'predicted_gap' : currentMode === 'sim' ? 'predicted_sim' : 'predicted';
            const predicted = indices.map(i => (d[predKey] || d.predicted)[i]);
            const actual = indices.map(i => d.actual[i]);
            const names = indices.map(i => d.names[i]);
            const temps = indices.map(i => d.temps[i]);
            const surfaces = indices.map(i => d.surfaces[i]);
            const isParkrun = indices.map(i => d.is_parkrun[i]);
            const tempAdjs = indices.map(i => (d.temp_adjs || [])[i] || 1.0);
            const surfaceAdjs = indices.map(i => (d.surface_adjs || [])[i] || 1.0);
            
            // Apply conditions adjustment to predictions if toggled
            let displayPredicted = predicted;
            if (adjustConditions) {
                displayPredicted = predicted.map((p, i) => {
                    if (p === null) return null;
                    // Duration-scaled heat: use predicted time as duration estimate
                    const estMins = p / 60.0;
                    const heatMult = Math.min(HEAT_MAX_MULT, estMins / HEAT_REF_MINS);
                    const tempFactor = 1.0 + (tempAdjs[i] - 1.0) * heatMult;
                    const surfFactor = surfaceAdjs[i];
                    return Math.round(p * tempFactor * surfFactor);
                });
            }
            
            // Colour actual dots: parkruns lighter, non-parkrun races darker
            const dotColors = isParkrun.map(p => p === 1 ? 'rgba(252, 165, 165, 0.8)' : 'rgba(239, 68, 68, 0.9)');
            
            // Build data points for time axis
            const predPoints = datesISO.map((dt, i) => displayPredicted[i] !== null ? ({ x: dt, y: displayPredicted[i] }) : null).filter(p => p !== null);
            const actualPoints = datesISO.map((dt, i) => ({ x: dt, y: actual[i] }));
            
            // Full prediction trend line (weekly smoothed, for distances with few races)
            const trendKey = currentMode === 'gap' ? 'trend_dates_iso_gap' : currentMode === 'sim' ? 'trend_dates_iso_sim' : 'trend_dates_iso';
            const trendValKey = currentMode === 'gap' ? 'trend_values_gap' : currentMode === 'sim' ? 'trend_values_sim' : 'trend_values';
            const trendDates = d[trendKey] || d.trend_dates_iso || [];
            const trendVals = d[trendValKey] || d.trend_values || [];
            const trendPoints = trendDates.map((dt, i) => ({ x: dt, y: trendVals[i] }));
            const fewRaces = actualPoints.length < 5;
            
            // Compute stable y-axis range covering both adjusted and unadjusted data
            const allYVals = [];
            for (let i = 0; i < actual.length; i++) { if (actual[i]) allYVals.push(actual[i]); }
            for (let i = 0; i < predicted.length; i++) { if (predicted[i]) allYVals.push(predicted[i]); }
            if (fewRaces) { for (let i = 0; i < trendVals.length; i++) { if (trendVals[i]) allYVals.push(trendVals[i]); } }
            // Also include worst-case adjusted predictions
            for (let i = 0; i < predicted.length; i++) {
                if (predicted[i] === null) continue;
                const estMins = predicted[i] / 60.0;
                const hm = Math.min(HEAT_MAX_MULT, estMins / HEAT_REF_MINS);
                const tf = 1.0 + (tempAdjs[i] - 1.0) * hm;
                const sf = surfaceAdjs[i];
                allYVals.push(Math.round(predicted[i] * tf * sf));
            }
            const yDataMin = Math.min(...allYVals);
            const yDataMax = Math.max(...allYVals);
            // Pick a nice round tick interval in seconds
            const ySpan = yDataMax - yDataMin;
            const niceSteps = [15, 30, 60, 120, 300, 600, 900, 1800, 3600];  // 15s to 1h
            let tickStep = 60;
            for (const s of niceSteps) {
                if (ySpan / s >= 3 && ySpan / s <= 8) { tickStep = s; break; }
            }
            // Round min down and max up to tick boundaries, then pad one tick
            const yMin = Math.floor(yDataMin / tickStep) * tickStep - tickStep;
            const yMax = Math.ceil(yDataMax / tickStep) * tickStep + tickStep;
            
            if (predChart) predChart.destroy();
            
            predChart = new Chart(predCtx.getContext('2d'), {
                type: 'line',
                data: {
                    datasets: [
                    // Background trend line (only for distances with < 5 races)
                    ...(fewRaces && trendPoints.length > 0 ? [{
                        label: 'Fitness trend',
                        data: trendPoints,
                        borderColor: (function() {
                            const modeBase = currentMode === 'gap' ? 'rgba(74, 222, 128,' : currentMode === 'sim' ? 'rgba(249, 115, 22,' : 'rgba(129, 140, 248,';
                            return modeBase + ' 0.3)';
                        })(),
                        backgroundColor: (function() {
                            const modeBase = currentMode === 'gap' ? 'rgba(74, 222, 128,' : currentMode === 'sim' ? 'rgba(249, 115, 22,' : 'rgba(129, 140, 248,';
                            return modeBase + ' 0.04)';
                        })(),
                        borderWidth: 1.5,
                        pointRadius: 0,
                        pointHitRadius: 0,
                        fill: true,
                        tension: 0.3,
                        order: 3,
                    }] : []),
                    {
                        label: adjustConditions ? 'Predicted (adj)' : 'Predicted',
                        data: predPoints,
                        borderColor: (function() {
                            const modeBase = currentMode === 'gap' ? 'rgba(74, 222, 128,' : currentMode === 'sim' ? 'rgba(249, 115, 22,' : 'rgba(129, 140, 248,';
                            return adjustConditions ? modeBase + ' 1)' : modeBase + ' 0.7)';
                        })(),
                        backgroundColor: (function() {
                            const modeBase = currentMode === 'gap' ? 'rgba(74, 222, 128,' : currentMode === 'sim' ? 'rgba(249, 115, 22,' : 'rgba(129, 140, 248,';
                            return modeBase + ' 0.05)';
                        })(),
                        borderDash: adjustConditions ? [4, 3] : [],
                        borderWidth: 2,
                        pointRadius: 0,
                        fill: !fewRaces,
                        tension: 0.3,
                    }, {
                        label: 'Actual',
                        data: actualPoints,
                        borderColor: 'rgba(239, 68, 68, 0.2)',
                        pointBackgroundColor: dotColors,
                        borderWidth: 1,
                        pointRadius: 3,
                        fill: false,
                        tension: 0,
                        showLine: true,
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                title: function(ctx) {
                                    // Find original index from ISO date
                                    const isoDate = ctx[0].raw.x;
                                    const i = datesISO.indexOf(isoDate);
                                    if (i < 0) return isoDate;
                                    return dates[i] + (names[i] ? ' ‚Äî ' + names[i] : '');
                                },
                                label: function(ctx) {
                                    return ctx.dataset.label + ': ' + formatPredTime(ctx.raw.y);
                                },
                                afterBody: function(ctx) {
                                    const isoDate = ctx[0].raw.x;
                                    const i = datesISO.indexOf(isoDate);
                                    if (i < 0) return [];
                                    const lines = [];
                                    // Gap vs prediction
                                    if (predicted[i] && actual[i]) {
                                        // If conditions toggled, compare actual vs adjusted prediction
                                        let compPred = predicted[i];
                                        if (adjustConditions) {
                                            const estMins = predicted[i] / 60.0;
                                            const heatMult = Math.min(HEAT_MAX_MULT, estMins / HEAT_REF_MINS);
                                            const tempFactor = 1.0 + (tempAdjs[i] - 1.0) * heatMult;
                                            const surfFactor = surfaceAdjs[i];
                                            compPred = Math.round(predicted[i] * tempFactor * surfFactor);
                                        }
                                        const gap = actual[i] - compPred;
                                        if (Math.abs(gap) < 2) {
                                            lines.push('Hit prediction exactly');
                                        } else {
                                            lines.push(formatPredTime(Math.abs(gap)) + (gap > 0 ? ' slower than prediction' : ' faster than prediction'));
                                        }
                                    }
                                    // Condition adjustments breakdown
                                    if (adjustConditions && (tempAdjs[i] !== 1.0 || surfaceAdjs[i] !== 1.0)) {
                                        const parts = [];
                                        if (tempAdjs[i] !== 1.0 && predicted[i]) {
                                            const estMins = predicted[i] / 60.0;
                                            const heatMult = Math.min(HEAT_MAX_MULT, estMins / HEAT_REF_MINS);
                                            const tempPct = ((tempAdjs[i] - 1.0) * heatMult * 100).toFixed(1);
                                            parts.push('temp +' + tempPct + '%');
                                        }
                                        if (surfaceAdjs[i] !== 1.0) {
                                            const surfPct = ((surfaceAdjs[i] - 1.0) * 100).toFixed(1);
                                            parts.push('surface +' + surfPct + '%');
                                        }
                                        if (parts.length > 0) lines.push('Adj: ' + parts.join(', '));
                                    }
                                    // Temperature
                                    if (temps[i] !== null) {
                                        const t = temps[i];
                                        let icon = '';
                                        if (t >= 25) icon = ' ü•µ';
                                        else if (t >= 20) icon = ' ‚òÄÔ∏è';
                                        else if (t <= 0) icon = ' ü•∂';
                                        lines.push('Temp: ' + t + '¬∞C' + icon);
                                    }
                                    // Surface
                                    if (surfaces[i]) {
                                        const surfaceIcons = { 'SNOW': '‚ùÑÔ∏è', 'HEAVY_SNOW': 'üå®Ô∏è', 'TRAIL': 'üå≤', 'TRACK': 'üèüÔ∏è', 'INDOOR_TRACK': 'üèüÔ∏è' };
                                        const icon = surfaceIcons[surfaces[i]] || '';
                                        lines.push(icon + ' ' + surfaces[i]);
                                    }
                                    return lines;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: { unit: 'year', displayFormats: { year: 'yyyy' } },
                            ticks: { maxTicksLimit: 10, font: { size: 10 } }
                        },
                        y: {
                            display: true,
                            reverse: true,
                            min: yMin,
                            max: yMax,
                            ticks: {
                                stepSize: tickStep,
                                callback: function(v) { return formatPredTime(v); },
                                font: { size: 10 }
                            }
                        }
                    }
                }
            });
        }
        
        if (predCtx && predData && predData['5k'] && predData['5k'].dates.length > 0) {
            renderPredChart('5k', showParkruns);
            
            document.getElementById('predToggle').addEventListener('click', function(e) {
                if (e.target.tagName === 'BUTTON') {
                    this.querySelectorAll('button').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    currentPredDist = e.target.dataset.dist;
                    renderPredChart(currentPredDist, showParkruns);
                }
            });
            
            document.getElementById('predParkrunToggle').addEventListener('change', function() {
                showParkruns = this.checked;
                renderPredChart(currentPredDist, showParkruns);
            });
            
            document.getElementById('predConditionsToggle').addEventListener('change', function() {
                adjustConditions = this.checked;
                renderPredChart(currentPredDist, showParkruns);
            });
        }
        
        // --- v51: Age Grade Trend Chart ---
        const agAllDates = [];
        const agAllDatesISO = [];
        const agAllValues = [];
        const agAllLabels = [];
        const agAllColors = [];
        const agAllSizes = [];
        const agAllParkrun = [];
        const agAllRolling = [];
        
        const agCtx = document.getElementById('agChart');
        let agChart = null;
        
        function getAgSlice(days) {
            if (days >= 99999) return { datesISO: agAllDatesISO, dates: agAllDates, values: agAllValues, labels: agAllLabels, colors: agAllColors, sizes: agAllSizes, parkrun: agAllParkrun, rolling: agAllRolling };
            const cutoff = new Date();
            cutoff.setDate(cutoff.getDate() - days);
            const indices = [];
            for (let i = 0; i < agAllDatesISO.length; i++) {
                if (new Date(agAllDatesISO[i]) >= cutoff) indices.push(i);
            }
            return {
                datesISO: indices.map(i => agAllDatesISO[i]),
                dates: indices.map(i => agAllDates[i]),
                values: indices.map(i => agAllValues[i]),
                labels: indices.map(i => agAllLabels[i]),
                colors: indices.map(i => agAllColors[i]),
                sizes: indices.map(i => agAllSizes[i]),
                parkrun: indices.map(i => agAllParkrun[i]),
                rolling: indices.map(i => agAllRolling[i])
            };
        }
        
        function renderAgChart(days) {
            const d = getAgSlice(days);
            if (d.datesISO.length === 0) return;
            
            if (agChart) agChart.destroy();
            
            // Build rolling average as line data (skip nulls)
            const rollingData = d.datesISO.map((dt, i) => d.rolling[i] !== null ? ({ x: dt, y: d.rolling[i] }) : null).filter(p => p !== null);
            
            agChart = new Chart(agCtx.getContext('2d'), {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Trend',
                        data: rollingData,
                        borderColor: 'rgba(220, 38, 38, 0.8)',
                        borderWidth: 2.5,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        pointHitRadius: 0,
                        showLine: true,
                        tension: 0.3,
                        type: 'line',
                        order: 1,
                    }, {
                        label: 'Age Grade %',
                        data: d.datesISO.map((dt, i) => ({ x: dt, y: d.values[i] })),
                        pointBackgroundColor: d.colors,
                        pointRadius: d.sizes,
                        order: 2,
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            filter: function(item) { return item.datasetIndex === 1; },
                            callbacks: {
                                title: function(ctx) { 
                                    if (!ctx.length || ctx[0].datasetIndex !== 1) return '';
                                    const i = ctx[0].dataIndex;
                                    return (i >= 0 && i < d.dates.length) ? d.dates[i] : '';
                                },
                                label: function(ctx) { 
                                    if (ctx.datasetIndex !== 1) return null;
                                    const i = ctx.dataIndex;
                                    if (i < 0 || i >= d.values.length) return '';
                                    const prefix = d.parkrun[i] ? 'üÖøÔ∏è parkrun ' : '';
                                    return prefix + d.labels[i] + ': ' + d.values[i] + '%'; 
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: days <= 730 ? 'month' : 'year',
                                displayFormats: { month: 'MMM yy', year: 'yyyy' }
                            },
                            ticks: { maxTicksLimit: 8, font: { size: 10 } }
                        },
                        y: {
                            display: true,
                            ticks: {
                                callback: function(v) { return v + '%'; },
                                font: { size: 10 }
                            }
                        }
                    }
                }
            });
        }
        
        if (agAllDates.length > 0) {
            renderAgChart(365);
            
            document.getElementById('agToggle').addEventListener('click', function(e) {
                if (e.target.tagName === 'BUTTON') {
                    this.querySelectorAll('button').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    renderAgChart(parseInt(e.target.dataset.range));
                }
            });
        }
        
        // --- Recent Runs toggle ---
        const recentRunsData = {
            all: [{"date": "19 Feb 26", "name": "Afternoon run", "dist": 11.9, "pace": "5:14", "npower": 22106, "hr": 136, "tss": 75, "rfl": 100, "rfl_gap": 100, "rfl_sim": 100, "race": false, "delta": null, "delta_gap": null, "delta_sim": null}],
            races: []
        };
        
        function updateRecentRunsTable(filter) {
            const runs = recentRunsData[filter];
            const tbody = document.getElementById('recentRunsBody');
            
            if (runs.length === 0) {
                tbody.innerHTML = '<tr><td colspan="8" style="text-align: center; color: var(--text-dim);">No races found</td></tr>';
                return;
            }
            
            tbody.innerHTML = runs.map(run => {
                // v51: Trend mover arrow (mode-aware)
                const modeDelta = currentMode === 'gap' ? run.delta_gap : currentMode === 'sim' ? run.delta_sim : run.delta;
                let deltaHtml = '';
                if (modeDelta !== null && modeDelta !== undefined) {
                    if (modeDelta >= 1.0) deltaHtml = '<span style="color:#16a34a;font-weight:bold;" title="RFL +' + modeDelta.toFixed(1) + '%"> ‚ñ≤‚ñ≤</span>';
                    else if (modeDelta >= 0.3) deltaHtml = '<span style="color:#16a34a;" title="RFL +' + modeDelta.toFixed(1) + '%"> ‚ñ≤</span>';
                    else if (modeDelta <= -1.0) deltaHtml = '<span style="color:#dc2626;font-weight:bold;" title="RFL ' + modeDelta.toFixed(1) + '%"> ‚ñº‚ñº</span>';
                    else if (modeDelta <= -0.3) deltaHtml = '<span style="color:#dc2626;" title="RFL ' + modeDelta.toFixed(1) + '%"> ‚ñº</span>';
                }
                const rflVal = currentMode === 'gap' ? (run.rfl_gap || '-') : currentMode === 'sim' ? (run.rfl_sim || '-') : (run.rfl || '-');
                return `
                <tr>
                    <td>${run.date}</td>
                    <td>${run.name} ${run.race ? '<span class="race-badge">RACE</span>' : ''}${deltaHtml}</td>
                    <td>${run.dist ? run.dist + ' km' : '-'}</td>
                    <td>${run.pace}</td>
                    <td class="power-only">${run.npower || '-'}</td>
                    <td>${run.hr || '-'}</td>
                    <td>${run.tss || '-'}</td>
                    <td>${rflVal}</td>
                </tr>`;
            }).join('');
        }
        
        // Initialize with all runs
        updateRecentRunsTable('all');
        
        // Toggle handler
        document.getElementById('recentRunsToggle').addEventListener('click', function(e) {
            if (e.target.tagName === 'BUTTON') {
                this.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
                e.target.classList.add('active');
                const filter = e.target.getAttribute('data-filter');
                updateRecentRunsTable(filter);
            }
        });
    
    // Phase 2: Mode switching
    function setMode(mode) {
        currentMode = mode;
        // Update toggle buttons
        document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
        document.getElementById('mode-' + mode).classList.add('active');
        
        // Update stats cards
        const ms = modeStats[mode];
        const rflEl = document.getElementById('rfl-value');
        if (rflEl) rflEl.textContent = ms.rfl + '%';
        const rflDeltaEl = document.getElementById('rfl-delta');
        if (rflDeltaEl) rflDeltaEl.textContent = ms.rflDelta;
        const agEl = document.getElementById('ag-value');
        if (agEl) agEl.textContent = (ms.ag && ms.ag !== 'None') ? ms.ag + '%' : '-';
        const p5 = document.getElementById('pred-5k');
        if (p5) p5.textContent = ms.pred5k;
        const p10 = document.getElementById('pred-10k');
        if (p10) p10.textContent = ms.pred10k;
        const ph = document.getElementById('pred-hm');
        if (ph) ph.textContent = ms.predHm;
        const pm = document.getElementById('pred-mara');
        if (pm) pm.textContent = ms.predMara;
        
        // Update RFL chart ‚Äî switch which data series is shown
        if (typeof rfChart !== 'undefined' && typeof currentRfRange !== 'undefined') {
            updateRfChart(currentRfRange);
        }
        
        // Update 14-day RFL trend chart
        if (typeof rfl14Chart !== 'undefined' && typeof updateRfl14Chart === 'function') {
            updateRfl14Chart(mode);
        }
        
        // Re-render prediction chart with mode-appropriate predictions
        if (typeof renderPredChart === 'function' && typeof currentPredDist !== 'undefined') {
            const showPR = document.getElementById('predParkrunToggle');
            renderPredChart(currentPredDist, showPR ? showPR.checked : false);
        }
        
        // Update RFL label
        const rflLabel = document.getElementById('rfl-label');
        if (rflLabel) {
            const labels = { stryd: 'RFL Trend', gap: 'RFL (GAP)', sim: 'RFL (Sim)' };
            rflLabel.textContent = labels[mode];
        }
        
        // Update Easy RF Gap stat card
        const easyGapEl = document.getElementById('easy-rf-gap-value');
        if (easyGapEl) {
            easyGapEl.textContent = easyGapEl.dataset[mode] || '-';
        }
        
        // Hide/show power-only elements via body class (CSS handles all hiding)
        const isGap = mode === 'gap';
        const isSim = mode === 'sim';
        document.body.classList.toggle('gap-mode', isGap);
        document.body.classList.toggle('sim-mode', isSim);
        
        // Update alert banner for current mode
        if (typeof renderAlertBanner === 'function') renderAlertBanner(mode);
        
        // Update zone badge (hide power info in GAP mode, use mode CP for Sim)
        const zb = document.getElementById('zone-badge');
        if (zb && typeof ZONE_CP !== 'undefined') {
            if (isGap) {
                zb.textContent = 'LTHR ' + ZONE_LTHR + ' ¬∑ Max ~' + ZONE_MAXHR;
            } else {
                const modeCP = mode === 'sim' ? Math.round(ZONE_PEAK_CP * parseFloat(modeStats.sim.rfl) / 100) : ZONE_CP;
                zb.textContent = 'CP ' + modeCP + 'W ¬∑ LTHR ' + ZONE_LTHR + ' ¬∑ Max ~' + ZONE_MAXHR;
            }
        }
        
        // Update top races description
        const trd = document.getElementById('top-races-desc');
        if (trd) trd.textContent = 'Best races by RFL% (fitness level at race date).';
        
        // Reset zone views when switching to GAP (use Race Pace as default)
        if (isGap) {
            const wkBtns = document.querySelectorAll('#wk-mode button');
            wkBtns.forEach(b => b.classList.remove('active'));
            // Find the gap-only Race (Pace) button and activate it
            const gapBtn = document.querySelector('#wk-mode .gap-only');
            if (gapBtn) { gapBtn.classList.add('active'); wkMode='race'; renderWk(); }
            const prBtns = document.querySelectorAll('#pr-mode button');
            prBtns.forEach(b => b.classList.remove('active'));
            const gapPrBtn = document.querySelector('#pr-mode .gap-only');
            if (gapPrBtn) { gapPrBtn.classList.add('active'); prMode='race'; renderPR(); }
        } else {
            // Switching back from GAP ‚Äî reset to HR zone view and re-activate button
            wkMode='hr'; prMode='hr';
            document.querySelectorAll('#wk-mode button').forEach(b => b.classList.remove('active'));
            const wkHrBtn = document.querySelector('#wk-mode button');
            if (wkHrBtn) wkHrBtn.classList.add('active');
            document.querySelectorAll('#pr-mode button').forEach(b => b.classList.remove('active'));
            const prHrBtn = document.querySelector('#pr-mode button');
            if (prHrBtn) prHrBtn.classList.add('active');
            if (typeof renderWk === 'function') renderWk();
            if (typeof renderPR === 'function') renderPR();
        }
        
        // Update race readiness cards (predicted time, target power/pace)
        const _surfF = {'indoor_track':{pw:1.0,re:1.04},'track':{pw:1.0,re:1.02},'road':{pw:1.0,re:1.0},'trail':{pw:0.95,re:0.97},'undulating_trail':{pw:0.90,re:0.95}};
        const _pdA=[[3,1.07],[5,1.05],[10,1.00],[21.097,0.95],[42.195,0.90]];
        function _roadCpF(d){d=Math.max(d,1);const ld=Math.log(d);if(ld<=Math.log(_pdA[0][0]))return _pdA[0][1];if(ld>=Math.log(_pdA[_pdA.length-1][0]))return _pdA[_pdA.length-1][1];for(let i=0;i<_pdA.length-1;i++){const l0=Math.log(_pdA[i][0]),l1=Math.log(_pdA[i+1][0]);if(ld>=l0&&ld<=l1){const f=(ld-l0)/(l1-l0);return _pdA[i][1]+f*(_pdA[i+1][1]-_pdA[i][1]);}}return 1.0;};
        // Map distance_key to modeStats raw seconds keys
        const _stepbKeyMap = {'5K':'pred5k_s','10K':'pred10k_s','HM':'predHm_s','Mara':'predMara_s'};
        PLANNED_RACES.forEach((race, idx) => {
            const dist = race.distance_km || 5.0;
            const sf = _surfF[race.surface||'road'] || _surfF.road;
            const factor = _roadCpF(dist) * sf.pw;
            const mcp = ms.cp;
            const pw = Math.round(mcp * factor);
            // Update power target
            const pwEl = document.getElementById('race-pw-' + idx);
            if (pwEl) pwEl.textContent = pw + 'W';
            // For standard road distances, use StepB predictions (matches stats grid)
            // For non-standard distances or non-road surfaces, use continuous model
            const stepbKey = _stepbKeyMap[race.distance_key];
            const stepbSecs = (stepbKey && (race.surface||'road')==='road') ? ms[stepbKey] : 0;
            let t;
            if (stepbSecs && stepbSecs > 0) {
                t = stepbSecs;
            } else {
                const re = (ZONE_RE || 0.914) * sf.re;
                const speed = (pw / 87.0) * re;
                t = speed > 0 ? Math.round(dist * 1000 / speed) : 0;
            }
            const predEl = document.getElementById('race-pred-' + idx);
            if (predEl && t > 0) {
                const hrs = Math.floor(t / 3600);
                const mins = Math.floor((t % 3600) / 60);
                const secs = t % 60;
                predEl.textContent = hrs > 0 ? hrs + ':' + String(mins).padStart(2,'0') + ':' + String(secs).padStart(2,'0') : mins + ':' + String(secs).padStart(2,'0');
            }
            // Update pace target
            const paceEl = document.getElementById('race-pace-' + idx);
            if (paceEl && t > 0) {
                const pace = t / dist;
                const pm = Math.floor(pace / 60);
                const ps = Math.round(pace % 60);
                paceEl.textContent = pm + ':' + String(ps).padStart(2,'0') + '/km';
            }
        });
        
        // Recalculate race readiness specificity (pace for GAP, power for others)
        if (typeof calcSpecificity === 'function') calcSpecificity();
        
        // Re-render recent runs and top races to apply power-only visibility
        if (typeof updateRecentRunsTable === 'function') {
            const activeFilter = document.querySelector('#recentRunsToggle button.active');
            updateRecentRunsTable(activeFilter ? activeFilter.getAttribute('data-filter') : 'all');
        }
        if (typeof updateTopRacesTable === 'function' && document.getElementById('topRacesBody')) {
            const activePeriod = document.querySelector('#topRacesToggle button.active');
            updateTopRacesTable(activePeriod ? activePeriod.getAttribute('data-period') : '1y');
        }
    }
    
    // Apply initial mode (ensures GAP athletes see GAP data on load)
    if (typeof setMode === 'function') setMode(currentMode);
    
    </script>
</body>
</html>
